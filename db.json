{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/assets/jscy.jpg","path":"assets/jscy.jpg","modified":1,"renderable":0},{"_id":"source/assets/mapreduce01.jpg","path":"assets/mapreduce01.jpg","modified":1,"renderable":0},{"_id":"source/assets/timedela.png","path":"assets/timedela.png","modified":1,"renderable":0},{"_id":"source/assets/webwxgeticon.jpg","path":"assets/webwxgeticon.jpg","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.507b3a.css","path":"main.507b3a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.507b3a.js","path":"main.507b3a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.fdc4b7.js","path":"mobile.fdc4b7.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"source/assets/mapreduce02.png","path":"assets/mapreduce02.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1505456805579},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1505456805579},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1505456805579},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1505456805579},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1505456805579},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1505456805579},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1505456805579},{"_id":"themes/yilia/_config.yml","hash":"ba1624dd6ad3fe62da8935b27cea6c0f2f4fc042","modified":1505981394274},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1505456805583},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1505456805587},{"_id":"source/_posts/apache-http-ssl模块NoClassDefFoundError-org-apache-http-ssl-TrustStrategy.md","hash":"fadd98749d4880fdd591fb900cd48f4a040d7824","modified":1505981491064},{"_id":"source/_posts/awk-按照某个key分发文件的妙用.md","hash":"1344e0742af723c0a017ec5b309bea13b05ba504","modified":1506308863768},{"_id":"source/_posts/git-commit-怎么撤销.md","hash":"405deea1aea8fc79c9ae91dcabc330811b7950ad","modified":1505982141249},{"_id":"source/_posts/hello-world.md","hash":"b0cb29fe8a370785ca5b8796f68276a6ac2a6f73","modified":1505819399309},{"_id":"source/_posts/hexo yilia github 搭建个人博客.md","hash":"14ce83d537cb4a5fc183ff129413bbd7a06caba7","modified":1505981860733},{"_id":"source/_posts/mapredcue 温习.md","hash":"7ebda6feda3c6e2e719a7d0be5b5353751edf3de","modified":1506650835624},{"_id":"source/_posts/mongo-中count的正确用法.md","hash":"e2e3a4662d95a47eda57d4aa84939f5c38860eb8","modified":1507859993354},{"_id":"source/_posts/mongo-中实现带where的group-by.md","hash":"d5d6dbfb25d30679861e24333408a3b1d089aff4","modified":1507605371229},{"_id":"source/_posts/python-实现聚合（单机版和mapreduce版本）.md","hash":"f2d0a9aedbfc55b89280d696f35c6dcf4d58988c","modified":1507775471453},{"_id":"source/_posts/python-操作mongo实现查询和聚合.md","hash":"b8838f4a81a14a89177f8121f4a2fba7f1a250f1","modified":1507788758103},{"_id":"source/_posts/shell-获取上个月或者上一年.md","hash":"0e06bb9f545d0904602ab69aecfe23242d988c06","modified":1505982745794},{"_id":"source/_posts/shell在指定行插入文本.md","hash":"a6ba11ec6902519087678158015d06cac907b819","modified":1505981909910},{"_id":"source/_posts/spark-lzo-体验.md","hash":"0701fa36bb1c517325d3e8c08b12297c8199e68b","modified":1505986097030},{"_id":"source/_posts/spark-项目启动的时候报出如下错误.md","hash":"d15d5455b30c88668e40c76c6eda82c17b78c7e4","modified":1506305907340},{"_id":"source/_posts/spark-scala中map和flatmap的区别.md","hash":"71237b9e7b3f91a361b07750fb79b61c95650388","modified":1505814861784},{"_id":"source/_posts/ssh-免登陆设置.md","hash":"ea9fcee1e236977ed370650edb117d3f5ea1cb81","modified":1506667679313},{"_id":"source/_posts/sublime-给文本排序.md","hash":"5ae95b8ae9460a5eb95b8ac34e2fef2a182726df","modified":1505984064551},{"_id":"source/_posts/ubantu16-04怎么彻底移除mysql.md","hash":"b57bb423d26ecb961449332a4fd0cf6d1817254e","modified":1505739758086},{"_id":"source/_posts/如何在ubantu中设置任务栏和菜单中的快速启动和搜索.md","hash":"089cdc18e669550cce0eaa3975329436951ececa","modified":1505981686335},{"_id":"source/assets/jscy.jpg","hash":"bc9c2b5a2b5b359a455d967ab315867bf2234a0e","modified":1505718119092},{"_id":"source/assets/mapreduce01.jpg","hash":"456efe62614d0de60b913d81951de7cf88b0f8cf","modified":1506322186196},{"_id":"source/assets/timedela.png","hash":"3f2c7574381b9b7cc1ade9a1ef576564747aafe4","modified":1507623179204},{"_id":"source/assets/webwxgeticon.jpg","hash":"86eeaa72afa031fc3aac08fc01bdf7709215acda","modified":1505815316307},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"93bcf8aa78ac5c538d67e3ddb820239876ac021e","modified":1505457828862},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1505456805559},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"d53be7839d02167197dd0413db038f26fa1380b3","modified":1505457828878},{"_id":"themes/yilia/.git/config","hash":"45dbf7cad960774e3ebd63f878005463a78e4c69","modified":1505456805559},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1505456784616},{"_id":"themes/yilia/.git/index","hash":"d85f9123234be82a983b0331df5e6479706752a9","modified":1505456805587},{"_id":"themes/yilia/.git/packed-refs","hash":"bedf7f90d58d21e413c3898f5a97bf2aa606f6d1","modified":1505456805559},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1505456805579},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1505456805579},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1505456805579},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1505456805579},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1505456805579},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1505456805579},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1505456805579},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1505456805583},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1505456805583},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1505456805583},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1505456805583},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1505456805583},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1505456805583},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1505456805583},{"_id":"themes/yilia/source/main.507b3a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1505456805587},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1505456805587},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1505456805583},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505456805583},{"_id":"themes/yilia/source/main.507b3a.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1505456805587},{"_id":"themes/yilia/source/mobile.fdc4b7.js","hash":"6bfff9bfe4d7e067b6289e851a4c424ac815af5e","modified":1505456805587},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1505456784616},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1505456784616},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1505456784616},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1505456784616},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1505456784616},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1505456784616},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1505456784616},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1505456784616},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1505456784616},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1505456784616},{"_id":"themes/yilia/.git/logs/HEAD","hash":"486b3dd1e029229c8a1be866ac09d47f3295f58d","modified":1505456805559},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"b011d92be321ebe09fa2b3179c08aa435b9d051c","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1505456805579},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1505456805583},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1505456805583},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1505456805587},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1505456805587},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1505456805587},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1505456805587},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1505456805587},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1505456805587},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1505456805587},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1505456805587},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1505456805583},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1505456805583},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1505456805583},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1505456805583},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1505456805583},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1505456805583},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1505456805583},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1505456805583},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1505456805583},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1505456805583},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1505456805583},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1505456805583},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1505456805583},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1505456805583},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1505456805583},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1505456805583},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1505456805583},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1505456805583},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1505456805583},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1505456805583},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1505456805583},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1505456805583},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1505456805583},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1505456805583},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1505456805583},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1505456805583},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1505456805583},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1505456805583},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1505456805583},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1505456805583},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1505456805583},{"_id":"themes/yilia/source-src/js/fix.js","hash":"7f9599ffd5c5551538e90b97023e7d6c599d1ee6","modified":1505456805583},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1505456805583},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1505456805583},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1505456805583},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1505456805583},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1505456805583},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1505456805583},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"e8a35d4497fe1e0f119662ae08bd8404e5dab2a4","modified":1505456805583},{"_id":"source/assets/mapreduce02.png","hash":"f0730acb3c13ab91edce23382963ac6da7b9a77a","modified":1506322399317},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"439f2afa6c3515a7edd67d512aae6eba5b1b0d0b","modified":1505456805583},{"_id":"themes/yilia/.git/objects/pack/pack-6feabf2504d5bc70f58e17bde6d19e2109ddb615.idx","hash":"ddd9d995aa032fc6525b7a4f28fbf41d5186a6cd","modified":1505456805431},{"_id":"themes/yilia/.git/refs/heads/master","hash":"d53be7839d02167197dd0413db038f26fa1380b3","modified":1505456805559},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"ec71ffc2023cebd933c96bd35a7a23d44a30a422","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1505456805583},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1505456805583},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1505456805583},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1505456805583},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1505456805583},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1505456805583},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1505456805583},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1505456805583},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1505456805583},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1505456805583},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1505456805583},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1505456805583},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1505456805583},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1505456805583},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"486b3dd1e029229c8a1be866ac09d47f3295f58d","modified":1505456805559},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1505456805559},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"486b3dd1e029229c8a1be866ac09d47f3295f58d","modified":1505456805559},{"_id":"themes/yilia/.git/objects/pack/pack-6feabf2504d5bc70f58e17bde6d19e2109ddb615.pack","hash":"8f5974b4335d46165db8acde921fe371fcdb4cf3","modified":1505456805431},{"_id":"public/content.json","hash":"5e2e45575040e0cf85f4eb7e2e73100f1c62934d","modified":1507861711922},{"_id":"public/2017/10/13/mongo-中count的正确用法/index.html","hash":"eccc004aa16ba9471f4eb054a1cd7befe5de33ac","modified":1507861712234},{"_id":"public/2017/10/12/python-操作mongo实现查询和聚合/index.html","hash":"91b4c770c778d7542760baede72d114e87eb46f9","modified":1507861712234},{"_id":"public/2017/10/10/python-实现聚合（单机版和mapreduce版本）/index.html","hash":"aacd08c532594ea4111fff38a5d005f64b3f7aef","modified":1507861712234},{"_id":"public/2017/10/09/mongo-中实现带where的group-by/index.html","hash":"b293cf0042c04fc8ab986520d7c39ccd2873dd02","modified":1507861712234},{"_id":"public/2017/09/29/ssh-免登陆设置/index.html","hash":"119701c41cb496819a79c2903d6407e7f5084281","modified":1507861712235},{"_id":"public/2017/09/29/mapredcue 温习/index.html","hash":"fec330a483cd4258577497b507f572fb7773e3d8","modified":1507861712235},{"_id":"public/2017/09/21/spark-lzo-体验/index.html","hash":"e76a6500cfd64a1f52ed0062099aa6ee5f8a43d7","modified":1507861712235},{"_id":"public/2017/09/21/sublime-给文本排序/index.html","hash":"8967d0f30c350827e0fa295be69930f46a2efa0d","modified":1507861712235},{"_id":"public/2017/09/21/shell-获取上个月或者上一年/index.html","hash":"92e6938b1022606725818b7f554991b1322e9a51","modified":1507861712235},{"_id":"public/2017/09/21/hexo yilia github 搭建个人博客/index.html","hash":"22c76cf84176a3fdd97b7c594f197bad37343b03","modified":1507861712235},{"_id":"public/2017/09/19/hello-world/index.html","hash":"9052ab170dd02819f8d4b637620f83f2d1d93b5a","modified":1507861712236},{"_id":"public/2017/09/19/spark-scala中map和flatmap的区别/index.html","hash":"5728d18fa2cd7aee1131ca34ff5542a2196af232","modified":1507861712236},{"_id":"public/2017/09/19/awk-按照某个key分发文件的妙用/index.html","hash":"390199337f3e5c08dd13eef53b51e741bf28b58b","modified":1507861712236},{"_id":"public/2017/09/19/如何在ubantu中设置任务栏和菜单中的快速启动和搜索/index.html","hash":"1aec2f768f056cb64c738c8fd0d70be6fc7921be","modified":1507861712236},{"_id":"public/2017/09/19/spark-项目启动的时候报出如下错误/index.html","hash":"0feb3c16573534f68d19e685d126997bbe0b6710","modified":1507861712236},{"_id":"public/2017/09/18/ubantu16-04怎么彻底移除mysql/index.html","hash":"4cc08f2affee962a8a9e6c99e0fed2f3bf3e642a","modified":1507861712236},{"_id":"public/2017/09/18/git-commit-怎么撤销/index.html","hash":"4d80a7aef034e76bb869f2674610154a93fad3ef","modified":1507861712237},{"_id":"public/2017/09/18/apache-http-ssl模块NoClassDefFoundError-org-apache-http-ssl-TrustStrategy/index.html","hash":"e48e69b67040e356ab06f13a9dafa468bd8d3e3a","modified":1507861712237},{"_id":"public/2017/09/18/shell在指定行插入文本/index.html","hash":"9ad3ee3f10b808f9b9d8f1ac7b214d54b243ec1e","modified":1507861712237},{"_id":"public/tags/apache-https-ssl-NoClassDefFound/index.html","hash":"12cc3246c1bb51497738896a494e023a46036fb8","modified":1507861712237},{"_id":"public/tags/shell-awk/index.html","hash":"58ae57cca69d62c745888936eadb7480a95e629f","modified":1507861712237},{"_id":"public/tags/git-commit/index.html","hash":"463497d0be2bce8c74962adf36be0825f02d9f8f","modified":1507861712237},{"_id":"public/tags/hexo-yilla-github/index.html","hash":"b889849b833512122fd92d27d8b12cb62256af7c","modified":1507861712238},{"_id":"public/tags/mapreduce-shuffer/index.html","hash":"5b007cdc799f803fcadf295cd8f1b56a98b29696","modified":1507861712238},{"_id":"public/tags/python-mongo-count/index.html","hash":"c4b3d0b09bbb1548ef6dc757a31ef5dcefffcc1e","modified":1507861712238},{"_id":"public/tags/mongo-groupby-where/index.html","hash":"889c377f4b707666fb79dfc7bb7527c141c1c2dc","modified":1507861712238},{"_id":"public/tags/python-date-count-sum-aggr-mean-panda/index.html","hash":"ca06feeddcc90c731044dee0a6a35c6b7a50fdf3","modified":1507861712238},{"_id":"public/tags/python-mongo/index.html","hash":"81699ebb0e77fc0c01641e55348cb86961468f70","modified":1507861712238},{"_id":"public/tags/shell-sed/index.html","hash":"8b8e212dee2b9cb8c93d46edba68f361b742f5ca","modified":1507861712238},{"_id":"public/tags/spark-lzo/index.html","hash":"7bdc6431576485e0810e753a56976c7d05f9262e","modified":1507861712238},{"_id":"public/tags/spark-not-match/index.html","hash":"dcecd949e9c39e624bd27e6e4d357cc9bbe829c9","modified":1507861712239},{"_id":"public/tags/spark-scala-map-flatmap/index.html","hash":"048e5ea89377431faf2accec10b718d6a0887c36","modified":1507861712239},{"_id":"public/tags/ssh-hadoop-spark/index.html","hash":"d9e7d63fa0c18b5cae770626ec659e2ddc157639","modified":1507861712239},{"_id":"public/tags/uabntu-mysql-移除-remove/index.html","hash":"1631ac1a6609b40e93b08a1f57bf10ff81a9ce07","modified":1507861712239},{"_id":"public/tags/ubantu-shell-dash/index.html","hash":"9c6bb75248c5cf3c08c49785926803000835f04b","modified":1507861712239},{"_id":"public/tags/shell-date/index.html","hash":"9486c247e3bb8936270b669231ed30ecc8f9c471","modified":1507861712239},{"_id":"public/index.html","hash":"eb02a269cedf2ce2c069d696435463fc5c8d5836","modified":1507861712239},{"_id":"public/page/2/index.html","hash":"93e113b0a73c488da6c1d6ea4f92958276807287","modified":1507861712240},{"_id":"public/archives/index.html","hash":"de529f6fe37cdb631856a65838c7af3dfc21c895","modified":1507861712240},{"_id":"public/archives/page/2/index.html","hash":"d35b6c1fcbc7d0a92e38514a157e97250d2ca427","modified":1507861712240},{"_id":"public/archives/2017/index.html","hash":"1938d683d41105ffd8331b815705fd7ea14dff7c","modified":1507861712240},{"_id":"public/archives/2017/page/2/index.html","hash":"150218ff2a224e7fb4599e732ebbccad60ada77e","modified":1507861712240},{"_id":"public/archives/2017/09/index.html","hash":"5962e532fcd8293a78d68835f05686304bfee606","modified":1507861712240},{"_id":"public/archives/2017/09/page/2/index.html","hash":"0fe9d45907d88fe6c848e38856e1c8c88cd72ce7","modified":1507861712241},{"_id":"public/archives/2017/10/index.html","hash":"1cc699f7508f92a0af6ca8959156747a25213ebe","modified":1507861712241},{"_id":"public/assets/jscy.jpg","hash":"bc9c2b5a2b5b359a455d967ab315867bf2234a0e","modified":1507861712245},{"_id":"public/assets/timedela.png","hash":"3f2c7574381b9b7cc1ade9a1ef576564747aafe4","modified":1507861712245},{"_id":"public/assets/mapreduce01.jpg","hash":"456efe62614d0de60b913d81951de7cf88b0f8cf","modified":1507861712245},{"_id":"public/assets/webwxgeticon.jpg","hash":"86eeaa72afa031fc3aac08fc01bdf7709215acda","modified":1507861712245},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1507861712245},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1507861712245},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1507861712245},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1507861712245},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1507861712245},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1507861712245},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1507861712245},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1507861712245},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1507861712246},{"_id":"public/main.507b3a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1507861712251},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1507861712251},{"_id":"public/mobile.fdc4b7.js","hash":"6bfff9bfe4d7e067b6289e851a4c424ac815af5e","modified":1507861712251},{"_id":"public/main.507b3a.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1507861712251},{"_id":"public/assets/mapreduce02.png","hash":"f0730acb3c13ab91edce23382963ac6da7b9a77a","modified":1507861712253}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"apache http ssl模块NoClassDefFoundError: org/apache/http/ssl/TrustStrategy","date":"2017-09-18T12:43:52.000Z","_content":"# 需求背景:\n>项目中有链接https接口的请求所以使用了,apache的httpcomponents中的httpclient,但是启动测试的时候报错，NoClassDefFoundError: org/apache/http/ssl/TrustStrategy\n\n## 解决方案:\n>然后找了下该类竟然出现在三个版本的包中，使用mvn dependency:tree >temp,找到了dubbo、disconf中也有出现，然后exclued掉.但是还是报错找不到类，后来发现该包正确使用的包在dubbo的引用下面，把该包的引用移动到上面，然后问题解决。","source":"_posts/apache-http-ssl模块NoClassDefFoundError-org-apache-http-ssl-TrustStrategy.md","raw":"---\ntitle: 'apache http ssl模块NoClassDefFoundError: org/apache/http/ssl/TrustStrategy'\ndate: 2017-09-18 20:43:52\ntags: apache https ssl NoClassDefFound\n---\n# 需求背景:\n>项目中有链接https接口的请求所以使用了,apache的httpcomponents中的httpclient,但是启动测试的时候报错，NoClassDefFoundError: org/apache/http/ssl/TrustStrategy\n\n## 解决方案:\n>然后找了下该类竟然出现在三个版本的包中，使用mvn dependency:tree >temp,找到了dubbo、disconf中也有出现，然后exclued掉.但是还是报错找不到类，后来发现该包正确使用的包在dubbo的引用下面，把该包的引用移动到上面，然后问题解决。","slug":"apache-http-ssl模块NoClassDefFoundError-org-apache-http-ssl-TrustStrategy","published":1,"updated":"2017-09-21T08:11:31.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xin60000y8zt85pibhfd","content":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h1><blockquote>\n<p>项目中有链接https接口的请求所以使用了,apache的httpcomponents中的httpclient,但是启动测试的时候报错，NoClassDefFoundError: org/apache/http/ssl/TrustStrategy</p>\n</blockquote>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><blockquote>\n<p>然后找了下该类竟然出现在三个版本的包中，使用mvn dependency:tree &gt;temp,找到了dubbo、disconf中也有出现，然后exclued掉.但是还是报错找不到类，后来发现该包正确使用的包在dubbo的引用下面，把该包的引用移动到上面，然后问题解决。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h1><blockquote>\n<p>项目中有链接https接口的请求所以使用了,apache的httpcomponents中的httpclient,但是启动测试的时候报错，NoClassDefFoundError: org/apache/http/ssl/TrustStrategy</p>\n</blockquote>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><blockquote>\n<p>然后找了下该类竟然出现在三个版本的包中，使用mvn dependency:tree &gt;temp,找到了dubbo、disconf中也有出现，然后exclued掉.但是还是报错找不到类，后来发现该包正确使用的包在dubbo的引用下面，把该包的引用移动到上面，然后问题解决。</p>\n</blockquote>\n"},{"title":"awk 按照某个key分发文件的妙用","date":"2017-09-19T06:45:19.000Z","toc":true,"comments":1,"_content":"## 需求背景：\n>本来的需求是提取一个月的数据，但是出来以后产品又要拆分为每天的量\n\n## 技术实现\n>本来打算使用python foreach去解决，但是想到以前用过awk处理过类似的问题，乍一看日期后面还有时分秒，必然又用到了substr，妙的是awk也支持，脚本如下：\n\n``` bash\nawk -F ',' '{print $3  >substr($2,1,10)\".csv\"}' sy*.txt;\n```\n>完美的解决了我的问题，第二列是时间(带有时分秒,日期格式为2017-06-13的样式)，第三列为个人标示，唯一标示一条记录，当然你也可以使用$0，完成真正意义上的拆分文件。\n\n``` bash\nawk -F ',' '{print $0 >substr($2,1,10)\".csv\"}'  sy*.txt;\n```\n","source":"_posts/awk-按照某个key分发文件的妙用.md","raw":"---\ntitle: awk 按照某个key分发文件的妙用\ndate: 2017-09-19 14:45:19\ntags: shell awk \ntoc: true\ncomments: true\n---\n## 需求背景：\n>本来的需求是提取一个月的数据，但是出来以后产品又要拆分为每天的量\n\n## 技术实现\n>本来打算使用python foreach去解决，但是想到以前用过awk处理过类似的问题，乍一看日期后面还有时分秒，必然又用到了substr，妙的是awk也支持，脚本如下：\n\n``` bash\nawk -F ',' '{print $3  >substr($2,1,10)\".csv\"}' sy*.txt;\n```\n>完美的解决了我的问题，第二列是时间(带有时分秒,日期格式为2017-06-13的样式)，第三列为个人标示，唯一标示一条记录，当然你也可以使用$0，完成真正意义上的拆分文件。\n\n``` bash\nawk -F ',' '{print $0 >substr($2,1,10)\".csv\"}'  sy*.txt;\n```\n","slug":"awk-按照某个key分发文件的妙用","published":1,"updated":"2017-09-25T03:07:43.768Z","layout":"post","photos":[],"link":"","_id":"cj8p9xinb0001y8zt5jwjmifm","content":"<h2 id=\"需求背景：\"><a href=\"#需求背景：\" class=\"headerlink\" title=\"需求背景：\"></a>需求背景：</h2><blockquote>\n<p>本来的需求是提取一个月的数据，但是出来以后产品又要拆分为每天的量</p>\n</blockquote>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><blockquote>\n<p>本来打算使用python foreach去解决，但是想到以前用过awk处理过类似的问题，乍一看日期后面还有时分秒，必然又用到了substr，妙的是awk也支持，脚本如下：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">','</span> <span class=\"string\">'&#123;print $3  &gt;substr($2,1,10)\".csv\"&#125;'</span> sy*.txt;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>完美的解决了我的问题，第二列是时间(带有时分秒,日期格式为2017-06-13的样式)，第三列为个人标示，唯一标示一条记录，当然你也可以使用$0，完成真正意义上的拆分文件。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">','</span> <span class=\"string\">'&#123;print $0 &gt;substr($2,1,10)\".csv\"&#125;'</span>  sy*.txt;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景：\"><a href=\"#需求背景：\" class=\"headerlink\" title=\"需求背景：\"></a>需求背景：</h2><blockquote>\n<p>本来的需求是提取一个月的数据，但是出来以后产品又要拆分为每天的量</p>\n</blockquote>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><blockquote>\n<p>本来打算使用python foreach去解决，但是想到以前用过awk处理过类似的问题，乍一看日期后面还有时分秒，必然又用到了substr，妙的是awk也支持，脚本如下：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">','</span> <span class=\"string\">'&#123;print $3  &gt;substr($2,1,10)\".csv\"&#125;'</span> sy*.txt;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>完美的解决了我的问题，第二列是时间(带有时分秒,日期格式为2017-06-13的样式)，第三列为个人标示，唯一标示一条记录，当然你也可以使用$0，完成真正意义上的拆分文件。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">','</span> <span class=\"string\">'&#123;print $0 &gt;substr($2,1,10)\".csv\"&#125;'</span>  sy*.txt;</div></pre></td></tr></table></figure>\n"},{"title":"Hello World","toc":true,"_content":"**终于搭建成功,散花!!!**","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntoc: true\n---\n**终于搭建成功,散花!!!**","slug":"hello-world","published":1,"date":"2017-09-19T11:09:59.309Z","updated":"2017-09-19T11:09:59.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xing0003y8ztnxir9dyw","content":"<p><strong>终于搭建成功,散花!!!</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>终于搭建成功,散花!!!</strong></p>\n"},{"title":"git commit 怎么撤销","date":"2017-09-18T12:54:49.000Z","_content":"\n# 需求背景:\n>当你不小心提交错某个文件或者或者多提交了某些文件，并且还没有push.\n\n>可以使用如下步骤来回退到提交前的状态.\t（ps:每次提交先stash,pull,stash pop 然后再commit,push）\n\t\n``` bash\ngit log \n```\n\n>会打印出所有的提交历史。\n>然后定位到自己想要回退到的对应版本,找到其hash值。\n\n``` shell\ncommit 0c17bf55de2054ffd6bd67714c75c0861618e3de\nAuthor: aa\nDate:   Tue Aug 8 18:14:16 2017 +0800\n\n    bug fix: aa fix\n\ncommit 7fc618a62b219829089cb47a6c04db95157a2b4f\nAuthor: bb\nDate:   Tue Aug 8 17:56:04 2017 +0800\n\n   bb fix bug\n```\n>然后使用git reset --hard commitid 回退到对应版本。","source":"_posts/git-commit-怎么撤销.md","raw":"---\ntitle: git commit 怎么撤销\ndate: 2017-09-18 20:54:49\ntags: git commit\n---\n\n# 需求背景:\n>当你不小心提交错某个文件或者或者多提交了某些文件，并且还没有push.\n\n>可以使用如下步骤来回退到提交前的状态.\t（ps:每次提交先stash,pull,stash pop 然后再commit,push）\n\t\n``` bash\ngit log \n```\n\n>会打印出所有的提交历史。\n>然后定位到自己想要回退到的对应版本,找到其hash值。\n\n``` shell\ncommit 0c17bf55de2054ffd6bd67714c75c0861618e3de\nAuthor: aa\nDate:   Tue Aug 8 18:14:16 2017 +0800\n\n    bug fix: aa fix\n\ncommit 7fc618a62b219829089cb47a6c04db95157a2b4f\nAuthor: bb\nDate:   Tue Aug 8 17:56:04 2017 +0800\n\n   bb fix bug\n```\n>然后使用git reset --hard commitid 回退到对应版本。","slug":"git-commit-怎么撤销","published":1,"updated":"2017-09-21T08:22:21.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xini0004y8ztx3r1ls6g","content":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h1><blockquote>\n<p>当你不小心提交错某个文件或者或者多提交了某些文件，并且还没有push.</p>\n<p>可以使用如下步骤来回退到提交前的状态.    （ps:每次提交先stash,pull,stash pop 然后再commit,push）</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">log</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>会打印出所有的提交历史。<br>然后定位到自己想要回退到的对应版本,找到其hash值。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">commit 0c17bf55de2054ffd6bd67714c75c0861618e3de</div><div class=\"line\">Author: aa</div><div class=\"line\">Date:   Tue Aug 8 18:14:16 2017 +0800</div><div class=\"line\"></div><div class=\"line\">    bug fix: aa fix</div><div class=\"line\"></div><div class=\"line\">commit 7fc618a62b219829089cb47a6c04db95157a2b4f</div><div class=\"line\">Author: bb</div><div class=\"line\">Date:   Tue Aug 8 17:56:04 2017 +0800</div><div class=\"line\"></div><div class=\"line\">   bb fix bug</div></pre></td></tr></table></figure>\n<blockquote>\n<p>然后使用git reset –hard commitid 回退到对应版本。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h1><blockquote>\n<p>当你不小心提交错某个文件或者或者多提交了某些文件，并且还没有push.</p>\n<p>可以使用如下步骤来回退到提交前的状态.    （ps:每次提交先stash,pull,stash pop 然后再commit,push）</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">log</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>会打印出所有的提交历史。<br>然后定位到自己想要回退到的对应版本,找到其hash值。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">commit 0c17bf55de2054ffd6bd67714c75c0861618e3de</div><div class=\"line\">Author: aa</div><div class=\"line\">Date:   Tue Aug 8 18:14:16 2017 +0800</div><div class=\"line\"></div><div class=\"line\">    bug fix: aa fix</div><div class=\"line\"></div><div class=\"line\">commit 7fc618a62b219829089cb47a6c04db95157a2b4f</div><div class=\"line\">Author: bb</div><div class=\"line\">Date:   Tue Aug 8 17:56:04 2017 +0800</div><div class=\"line\"></div><div class=\"line\">   bb fix bug</div></pre></td></tr></table></figure>\n<blockquote>\n<p>然后使用git reset –hard commitid 回退到对应版本。</p>\n</blockquote>\n"},{"title":"hexo yilla 和github 结合搭建个人博客","toc":true,"comments":1,"_content":"\n\n# 为什么考虑这样的搭配方式?\n## 构建需求\n >现阶段有很多的技术网站都带有给想要展示自己的一些技术入门以及技术研究的平台,也就常见的技术博客.\n  但是大多都不满足于个性化定制,偶然间接触到markdown,当然简书等这样的平台也支持markdown,但是出于个人的独占情节,还是更倾向于搭建一个独立的自己可控的blog.\n\n## 技术实现(快速搭建)\n>考虑到如果从零开始,买空间,选域名,构建主体框架,渲染静态页面,一套走下来,未免本末倒置,博客注重的应该是文章的可读性以及质量,当然ui需要一定的可观瞻性.幸运的是遇到了hexo,给人一种转角遇到爱的小确幸.\n\t  ps:Hexo is a fast, simple & powerful blog framework powered by Node.js.\n\t  从官网的解释可以看出,我们需要安装Node.js,当然要和gitbub结合,你需要申请一个github账号,申请账号的步骤,此处就不再累述.\n\t  笔者使用的系统是ubantu 16.04\n\t  \n>传送门:[github账号申请]( https://github.com/join)\n\n### 现在演示安装Node.js.\n> 在 Github 上获取 Node.js 源码：\n\n``` bash\n$ sudo git clone https://github.com/nodejs/node.git\n```\n\n 1.修改目录权限：\n``` bash\n$ sudo chmod -R 755 node\n$ cd node\n$ node -v\n```\n 2.使用 ./configure 创建编译文件\n``` bash\n$ sudo ./configure \n```\n 3.这一步，可能时间有点长，耐心等待\n``` bash\n$ sudo make \n```\n 4.最后\n``` bash\n$ sudo make \n```\n\n>install 查看版本\n\n``` bash\n$ node -v\n```\n>v0.10.25 如果node不是最新的，node有一个模块叫n，是专门用来管理node.js的版本的。使用npm（NPM是随同nodejs一起安装的包管理工具）安装n模块\n\n``` bash\n$ sudo npm install -g n  \n```\n>然后，升级node.js到最新稳定版\n\n``` bash\n$ sudo n stable  \n```\n>旧版本的 npm，也可以很容易地通过 npm 命令来升级，命令如下：\n\n``` bash\n$ sudo npm install npm -g\n```\n\n### 安装hexo\n\n>执行以下的命令:\n\n``` bash\n$ npm install hexo-cli -g\n$ hexo init blog 此处会新建一个新的目录存储hexo的一些初始化的文件.\n$ cd blog\n$ npm install\n$ hexo server 此处会生成一个新的本地预览 访问http://localhost:4000 就可以访问本地的默认主题.\n```\n\n### 新建github仓库\n>新建一个仓库,然后选择public权限(写博客不就是为了别人看,进而监督自己进步么,所以public),指定git分支,使用默认的master分支即可,因为这个仓库就你一个看门的,这里面也是你的.然后记住自己的clone地址.\n>ps:记得保存.\n\n### 将gitbub仓库和hexo主题绑定\n>编辑_config.yml:\n\t\n``` less\n  type: git\n  repo: https://github.com/tangyuxiaoyao/ITWO.git\n  branch: master\n```\n>repo配置的地址为上文已经提及过的项目仓库clone地址.\n>而且这里有看到仓库后面带有子资源路径所以参考配置文件中的注释,需要将root对应的配置改为仓库的名称资源路径.\n\n``` vim\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nroot: /ITWO/\n```\n\n\n### 发布主题到github仓库\n\n``` bash\nnpm install hexo-deployer-git --save\nhexo clean && hexo g && hexo d\n```\n 1. 安装hexo发布模块deploy\n 2. 清除缓存\n 3. 生成静态页面\n 4. 发布到github(每次改完以后也是这么稳妥发布)\n### 生成新的文章\n\n``` bash\n$ cd source/_posts/\n$ hexo new \"shell在指定行插入文本\"\n```\n\n\n>然后就会生成一个为该名称的md文件,根据md语法编辑内容,完成以后发布即可.\nps:可以用hexo clean && hexo g && hexo s在本地生成预览效果,避免发布到github上的效果不尽人意.\n\n\n![古人笑比庭中树,一日秋风一日疏](/ITWO/assets/jscy.jpg)","source":"_posts/hexo yilia github 搭建个人博客.md","raw":"---\ntitle: hexo yilla 和github 结合搭建个人博客 \ntags: hexo yilla github\ntoc: true\ncomments: true\n---\n\n\n# 为什么考虑这样的搭配方式?\n## 构建需求\n >现阶段有很多的技术网站都带有给想要展示自己的一些技术入门以及技术研究的平台,也就常见的技术博客.\n  但是大多都不满足于个性化定制,偶然间接触到markdown,当然简书等这样的平台也支持markdown,但是出于个人的独占情节,还是更倾向于搭建一个独立的自己可控的blog.\n\n## 技术实现(快速搭建)\n>考虑到如果从零开始,买空间,选域名,构建主体框架,渲染静态页面,一套走下来,未免本末倒置,博客注重的应该是文章的可读性以及质量,当然ui需要一定的可观瞻性.幸运的是遇到了hexo,给人一种转角遇到爱的小确幸.\n\t  ps:Hexo is a fast, simple & powerful blog framework powered by Node.js.\n\t  从官网的解释可以看出,我们需要安装Node.js,当然要和gitbub结合,你需要申请一个github账号,申请账号的步骤,此处就不再累述.\n\t  笔者使用的系统是ubantu 16.04\n\t  \n>传送门:[github账号申请]( https://github.com/join)\n\n### 现在演示安装Node.js.\n> 在 Github 上获取 Node.js 源码：\n\n``` bash\n$ sudo git clone https://github.com/nodejs/node.git\n```\n\n 1.修改目录权限：\n``` bash\n$ sudo chmod -R 755 node\n$ cd node\n$ node -v\n```\n 2.使用 ./configure 创建编译文件\n``` bash\n$ sudo ./configure \n```\n 3.这一步，可能时间有点长，耐心等待\n``` bash\n$ sudo make \n```\n 4.最后\n``` bash\n$ sudo make \n```\n\n>install 查看版本\n\n``` bash\n$ node -v\n```\n>v0.10.25 如果node不是最新的，node有一个模块叫n，是专门用来管理node.js的版本的。使用npm（NPM是随同nodejs一起安装的包管理工具）安装n模块\n\n``` bash\n$ sudo npm install -g n  \n```\n>然后，升级node.js到最新稳定版\n\n``` bash\n$ sudo n stable  \n```\n>旧版本的 npm，也可以很容易地通过 npm 命令来升级，命令如下：\n\n``` bash\n$ sudo npm install npm -g\n```\n\n### 安装hexo\n\n>执行以下的命令:\n\n``` bash\n$ npm install hexo-cli -g\n$ hexo init blog 此处会新建一个新的目录存储hexo的一些初始化的文件.\n$ cd blog\n$ npm install\n$ hexo server 此处会生成一个新的本地预览 访问http://localhost:4000 就可以访问本地的默认主题.\n```\n\n### 新建github仓库\n>新建一个仓库,然后选择public权限(写博客不就是为了别人看,进而监督自己进步么,所以public),指定git分支,使用默认的master分支即可,因为这个仓库就你一个看门的,这里面也是你的.然后记住自己的clone地址.\n>ps:记得保存.\n\n### 将gitbub仓库和hexo主题绑定\n>编辑_config.yml:\n\t\n``` less\n  type: git\n  repo: https://github.com/tangyuxiaoyao/ITWO.git\n  branch: master\n```\n>repo配置的地址为上文已经提及过的项目仓库clone地址.\n>而且这里有看到仓库后面带有子资源路径所以参考配置文件中的注释,需要将root对应的配置改为仓库的名称资源路径.\n\n``` vim\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nroot: /ITWO/\n```\n\n\n### 发布主题到github仓库\n\n``` bash\nnpm install hexo-deployer-git --save\nhexo clean && hexo g && hexo d\n```\n 1. 安装hexo发布模块deploy\n 2. 清除缓存\n 3. 生成静态页面\n 4. 发布到github(每次改完以后也是这么稳妥发布)\n### 生成新的文章\n\n``` bash\n$ cd source/_posts/\n$ hexo new \"shell在指定行插入文本\"\n```\n\n\n>然后就会生成一个为该名称的md文件,根据md语法编辑内容,完成以后发布即可.\nps:可以用hexo clean && hexo g && hexo s在本地生成预览效果,避免发布到github上的效果不尽人意.\n\n\n![古人笑比庭中树,一日秋风一日疏](/ITWO/assets/jscy.jpg)","slug":"hexo yilia github 搭建个人博客","published":1,"date":"2017-09-21T08:17:40.733Z","updated":"2017-09-21T08:17:40.733Z","layout":"post","photos":[],"link":"","_id":"cj8p9xinj0005y8ztt7szv5ew","content":"<h1 id=\"为什么考虑这样的搭配方式\"><a href=\"#为什么考虑这样的搭配方式\" class=\"headerlink\" title=\"为什么考虑这样的搭配方式?\"></a>为什么考虑这样的搭配方式?</h1><h2 id=\"构建需求\"><a href=\"#构建需求\" class=\"headerlink\" title=\"构建需求\"></a>构建需求</h2><blockquote>\n<p>现阶段有很多的技术网站都带有给想要展示自己的一些技术入门以及技术研究的平台,也就常见的技术博客.<br>  但是大多都不满足于个性化定制,偶然间接触到markdown,当然简书等这样的平台也支持markdown,但是出于个人的独占情节,还是更倾向于搭建一个独立的自己可控的blog.</p>\n</blockquote>\n<h2 id=\"技术实现-快速搭建\"><a href=\"#技术实现-快速搭建\" class=\"headerlink\" title=\"技术实现(快速搭建)\"></a>技术实现(快速搭建)</h2><blockquote>\n<p>考虑到如果从零开始,买空间,选域名,构建主体框架,渲染静态页面,一套走下来,未免本末倒置,博客注重的应该是文章的可读性以及质量,当然ui需要一定的可观瞻性.幸运的是遇到了hexo,给人一种转角遇到爱的小确幸.<br>      ps:Hexo is a fast, simple &amp; powerful blog framework powered by Node.js.<br>      从官网的解释可以看出,我们需要安装Node.js,当然要和gitbub结合,你需要申请一个github账号,申请账号的步骤,此处就不再累述.<br>      笔者使用的系统是ubantu 16.04</p>\n<p>传送门:<a href=\"https://github.com/join\" target=\"_blank\" rel=\"external\">github账号申请</a></p>\n</blockquote>\n<h3 id=\"现在演示安装Node-js\"><a href=\"#现在演示安装Node-js\" class=\"headerlink\" title=\"现在演示安装Node.js.\"></a>现在演示安装Node.js.</h3><blockquote>\n<p>在 Github 上获取 Node.js 源码：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo git <span class=\"built_in\">clone</span> https://github.com/nodejs/node.git</div></pre></td></tr></table></figure>\n<p> 1.修改目录权限：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo chmod -R 755 node</div><div class=\"line\">$ <span class=\"built_in\">cd</span> node</div><div class=\"line\">$ node -v</div></pre></td></tr></table></figure></p>\n<p> 2.使用 ./configure 创建编译文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo ./configure</div></pre></td></tr></table></figure></p>\n<p> 3.这一步，可能时间有点长，耐心等待<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo make</div></pre></td></tr></table></figure></p>\n<p> 4.最后<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo make</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>install 查看版本</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node -v</div></pre></td></tr></table></figure>\n<blockquote>\n<p>v0.10.25 如果node不是最新的，node有一个模块叫n，是专门用来管理node.js的版本的。使用npm（NPM是随同nodejs一起安装的包管理工具）安装n模块</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo npm install -g n</div></pre></td></tr></table></figure>\n<blockquote>\n<p>然后，升级node.js到最新稳定版</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo n stable</div></pre></td></tr></table></figure>\n<blockquote>\n<p>旧版本的 npm，也可以很容易地通过 npm 命令来升级，命令如下：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo npm install npm -g</div></pre></td></tr></table></figure>\n<h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><blockquote>\n<p>执行以下的命令:</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-cli -g</div><div class=\"line\">$ hexo init blog 此处会新建一个新的目录存储hexo的一些初始化的文件.</div><div class=\"line\">$ <span class=\"built_in\">cd</span> blog</div><div class=\"line\">$ npm install</div><div class=\"line\">$ hexo server 此处会生成一个新的本地预览 访问http://localhost:4000 就可以访问本地的默认主题.</div></pre></td></tr></table></figure>\n<h3 id=\"新建github仓库\"><a href=\"#新建github仓库\" class=\"headerlink\" title=\"新建github仓库\"></a>新建github仓库</h3><blockquote>\n<p>新建一个仓库,然后选择public权限(写博客不就是为了别人看,进而监督自己进步么,所以public),指定git分支,使用默认的master分支即可,因为这个仓库就你一个看门的,这里面也是你的.然后记住自己的clone地址.<br>ps:记得保存.</p>\n</blockquote>\n<h3 id=\"将gitbub仓库和hexo主题绑定\"><a href=\"#将gitbub仓库和hexo主题绑定\" class=\"headerlink\" title=\"将gitbub仓库和hexo主题绑定\"></a>将gitbub仓库和hexo主题绑定</h3><blockquote>\n<p>编辑_config.yml:</p>\n</blockquote>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">type</span>: git</div><div class=\"line\"><span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/tangyuxiaoyao/ITWO.git</span></div><div class=\"line\"><span class=\"attribute\">branch</span>: master</div></pre></td></tr></table></figure>\n<blockquote>\n<p>repo配置的地址为上文已经提及过的项目仓库clone地址.<br>而且这里有看到仓库后面带有子资源路径所以参考配置文件中的注释,需要将root对应的配置改为仓库的名称资源路径.</p>\n</blockquote>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># URL</div><div class=\"line\">## If your site <span class=\"keyword\">is</span> <span class=\"keyword\">put</span> in <span class=\"keyword\">a</span> subdirectory, <span class=\"keyword\">set</span> url <span class=\"keyword\">as</span> <span class=\"string\">'http://yoursite.com/child'</span> <span class=\"built_in\">and</span> root <span class=\"keyword\">as</span> <span class=\"string\">'/child/'</span></div><div class=\"line\">roo<span class=\"variable\">t:</span> /ITWO/</div></pre></td></tr></table></figure>\n<h3 id=\"发布主题到github仓库\"><a href=\"#发布主题到github仓库\" class=\"headerlink\" title=\"发布主题到github仓库\"></a>发布主题到github仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</div></pre></td></tr></table></figure>\n<ol>\n<li>安装hexo发布模块deploy</li>\n<li>清除缓存</li>\n<li>生成静态页面</li>\n<li>发布到github(每次改完以后也是这么稳妥发布)<h3 id=\"生成新的文章\"><a href=\"#生成新的文章\" class=\"headerlink\" title=\"生成新的文章\"></a>生成新的文章</h3></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ <span class=\"built_in\">cd</span> <span class=\"built_in\">source</span>/_posts/</div><div class=\"line\">$ hexo new <span class=\"string\">\"shell在指定行插入文本\"</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>然后就会生成一个为该名称的md文件,根据md语法编辑内容,完成以后发布即可.<br>ps:可以用hexo clean &amp;&amp; hexo g &amp;&amp; hexo s在本地生成预览效果,避免发布到github上的效果不尽人意.</p>\n</blockquote>\n<p><img src=\"/ITWO/assets/jscy.jpg\" alt=\"古人笑比庭中树,一日秋风一日疏\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么考虑这样的搭配方式\"><a href=\"#为什么考虑这样的搭配方式\" class=\"headerlink\" title=\"为什么考虑这样的搭配方式?\"></a>为什么考虑这样的搭配方式?</h1><h2 id=\"构建需求\"><a href=\"#构建需求\" class=\"headerlink\" title=\"构建需求\"></a>构建需求</h2><blockquote>\n<p>现阶段有很多的技术网站都带有给想要展示自己的一些技术入门以及技术研究的平台,也就常见的技术博客.<br>  但是大多都不满足于个性化定制,偶然间接触到markdown,当然简书等这样的平台也支持markdown,但是出于个人的独占情节,还是更倾向于搭建一个独立的自己可控的blog.</p>\n</blockquote>\n<h2 id=\"技术实现-快速搭建\"><a href=\"#技术实现-快速搭建\" class=\"headerlink\" title=\"技术实现(快速搭建)\"></a>技术实现(快速搭建)</h2><blockquote>\n<p>考虑到如果从零开始,买空间,选域名,构建主体框架,渲染静态页面,一套走下来,未免本末倒置,博客注重的应该是文章的可读性以及质量,当然ui需要一定的可观瞻性.幸运的是遇到了hexo,给人一种转角遇到爱的小确幸.<br>      ps:Hexo is a fast, simple &amp; powerful blog framework powered by Node.js.<br>      从官网的解释可以看出,我们需要安装Node.js,当然要和gitbub结合,你需要申请一个github账号,申请账号的步骤,此处就不再累述.<br>      笔者使用的系统是ubantu 16.04</p>\n<p>传送门:<a href=\"https://github.com/join\" target=\"_blank\" rel=\"external\">github账号申请</a></p>\n</blockquote>\n<h3 id=\"现在演示安装Node-js\"><a href=\"#现在演示安装Node-js\" class=\"headerlink\" title=\"现在演示安装Node.js.\"></a>现在演示安装Node.js.</h3><blockquote>\n<p>在 Github 上获取 Node.js 源码：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo git <span class=\"built_in\">clone</span> https://github.com/nodejs/node.git</div></pre></td></tr></table></figure>\n<p> 1.修改目录权限：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo chmod -R 755 node</div><div class=\"line\">$ <span class=\"built_in\">cd</span> node</div><div class=\"line\">$ node -v</div></pre></td></tr></table></figure></p>\n<p> 2.使用 ./configure 创建编译文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo ./configure</div></pre></td></tr></table></figure></p>\n<p> 3.这一步，可能时间有点长，耐心等待<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo make</div></pre></td></tr></table></figure></p>\n<p> 4.最后<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo make</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>install 查看版本</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node -v</div></pre></td></tr></table></figure>\n<blockquote>\n<p>v0.10.25 如果node不是最新的，node有一个模块叫n，是专门用来管理node.js的版本的。使用npm（NPM是随同nodejs一起安装的包管理工具）安装n模块</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo npm install -g n</div></pre></td></tr></table></figure>\n<blockquote>\n<p>然后，升级node.js到最新稳定版</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo n stable</div></pre></td></tr></table></figure>\n<blockquote>\n<p>旧版本的 npm，也可以很容易地通过 npm 命令来升级，命令如下：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo npm install npm -g</div></pre></td></tr></table></figure>\n<h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><blockquote>\n<p>执行以下的命令:</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-cli -g</div><div class=\"line\">$ hexo init blog 此处会新建一个新的目录存储hexo的一些初始化的文件.</div><div class=\"line\">$ <span class=\"built_in\">cd</span> blog</div><div class=\"line\">$ npm install</div><div class=\"line\">$ hexo server 此处会生成一个新的本地预览 访问http://localhost:4000 就可以访问本地的默认主题.</div></pre></td></tr></table></figure>\n<h3 id=\"新建github仓库\"><a href=\"#新建github仓库\" class=\"headerlink\" title=\"新建github仓库\"></a>新建github仓库</h3><blockquote>\n<p>新建一个仓库,然后选择public权限(写博客不就是为了别人看,进而监督自己进步么,所以public),指定git分支,使用默认的master分支即可,因为这个仓库就你一个看门的,这里面也是你的.然后记住自己的clone地址.<br>ps:记得保存.</p>\n</blockquote>\n<h3 id=\"将gitbub仓库和hexo主题绑定\"><a href=\"#将gitbub仓库和hexo主题绑定\" class=\"headerlink\" title=\"将gitbub仓库和hexo主题绑定\"></a>将gitbub仓库和hexo主题绑定</h3><blockquote>\n<p>编辑_config.yml:</p>\n</blockquote>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">type</span>: git</div><div class=\"line\"><span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/tangyuxiaoyao/ITWO.git</span></div><div class=\"line\"><span class=\"attribute\">branch</span>: master</div></pre></td></tr></table></figure>\n<blockquote>\n<p>repo配置的地址为上文已经提及过的项目仓库clone地址.<br>而且这里有看到仓库后面带有子资源路径所以参考配置文件中的注释,需要将root对应的配置改为仓库的名称资源路径.</p>\n</blockquote>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># URL</div><div class=\"line\">## If your site <span class=\"keyword\">is</span> <span class=\"keyword\">put</span> in <span class=\"keyword\">a</span> subdirectory, <span class=\"keyword\">set</span> url <span class=\"keyword\">as</span> <span class=\"string\">'http://yoursite.com/child'</span> <span class=\"built_in\">and</span> root <span class=\"keyword\">as</span> <span class=\"string\">'/child/'</span></div><div class=\"line\">roo<span class=\"variable\">t:</span> /ITWO/</div></pre></td></tr></table></figure>\n<h3 id=\"发布主题到github仓库\"><a href=\"#发布主题到github仓库\" class=\"headerlink\" title=\"发布主题到github仓库\"></a>发布主题到github仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</div></pre></td></tr></table></figure>\n<ol>\n<li>安装hexo发布模块deploy</li>\n<li>清除缓存</li>\n<li>生成静态页面</li>\n<li>发布到github(每次改完以后也是这么稳妥发布)<h3 id=\"生成新的文章\"><a href=\"#生成新的文章\" class=\"headerlink\" title=\"生成新的文章\"></a>生成新的文章</h3></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ <span class=\"built_in\">cd</span> <span class=\"built_in\">source</span>/_posts/</div><div class=\"line\">$ hexo new <span class=\"string\">\"shell在指定行插入文本\"</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>然后就会生成一个为该名称的md文件,根据md语法编辑内容,完成以后发布即可.<br>ps:可以用hexo clean &amp;&amp; hexo g &amp;&amp; hexo s在本地生成预览效果,避免发布到github上的效果不尽人意.</p>\n</blockquote>\n<p><img src=\"/ITWO/assets/jscy.jpg\" alt=\"古人笑比庭中树,一日秋风一日疏\"></p>\n"},{"title":"mapreduce 温故","toc":true,"comments":1,"_content":"\n## 需求背景：\n>做大数据有一段时间了，梳理下用到mapreduce的一些问题和解决方案。\n\n## mapreduce\n>mapreduce:顾名思义，map做映射，reduce做规约。\n>主要分以下步骤：\n1.输入分块\n2.map\n3.shuffer\n4.reduce\n\n![mapredcue流程图](/ITWO/assets/mapreduce01.jpg)\n重点是shuffer阶段\n\n\n## reduce个数的计算方法:\n\n``` java\ndouble bytes = Math.max(totalInputFileSize, bytesPerReducer);\nint reducers = (int) Math.ceil(bytes / bytesPerReducer);\nreducers = Math.max(1, reducers);\nreducers = Math.min(maxReducers, reducers);\n```\n>　从计算逻辑可以看出该量由输入文件的大小以及设置的每个reduce可以处理的字节数大小决定．\n\n>　map接受分块数据，然后使用默认的分区算法（对输入文件的kv中对key hash后再对reduce task数量取模(reduce个数的算法见前文)），再通过内存缓冲区进行排序．\n>　这个溢写是由单独线程来完成，不影响往缓冲区写map结果的线程。溢写线程启动时不应该阻止map的结果输出，所以整个缓冲区有个溢写的比例spill.percent。这个比例默认是0.8，也就是当缓冲区的数据已经达到阈值（buffer size * spill percent = 100MB * 0.8 = 80MB），溢写线程启动，锁定这80MB的内存，执行溢写过程。Map task的输出结果还可以往剩下的20MB内存中写，互不影响。\n> 　达到阈值以后溢写到磁盘上，排序用的是字典顺序的排序,排序的对象是序列化好的字节。最后溢写得到的多个文件根据hash值merge，也可以自定义combiner（可以理解为map端的reduce）），然后reduce开始fetch（拉取）map端合并好的数据，拉取来自不同map的相同分区的数据（相同key的数据）过来，然后在reduce端合并，此时在reduce端也会进行一次sort。\n\n![shuffer流程图](/ITWO/assets/mapreduce02.png)\n\n","source":"_posts/mapredcue 温习.md","raw":"---\ntitle: mapreduce 温故\ntags: mapreduce shuffer\ntoc: true\ncomments: true\n---\n\n## 需求背景：\n>做大数据有一段时间了，梳理下用到mapreduce的一些问题和解决方案。\n\n## mapreduce\n>mapreduce:顾名思义，map做映射，reduce做规约。\n>主要分以下步骤：\n1.输入分块\n2.map\n3.shuffer\n4.reduce\n\n![mapredcue流程图](/ITWO/assets/mapreduce01.jpg)\n重点是shuffer阶段\n\n\n## reduce个数的计算方法:\n\n``` java\ndouble bytes = Math.max(totalInputFileSize, bytesPerReducer);\nint reducers = (int) Math.ceil(bytes / bytesPerReducer);\nreducers = Math.max(1, reducers);\nreducers = Math.min(maxReducers, reducers);\n```\n>　从计算逻辑可以看出该量由输入文件的大小以及设置的每个reduce可以处理的字节数大小决定．\n\n>　map接受分块数据，然后使用默认的分区算法（对输入文件的kv中对key hash后再对reduce task数量取模(reduce个数的算法见前文)），再通过内存缓冲区进行排序．\n>　这个溢写是由单独线程来完成，不影响往缓冲区写map结果的线程。溢写线程启动时不应该阻止map的结果输出，所以整个缓冲区有个溢写的比例spill.percent。这个比例默认是0.8，也就是当缓冲区的数据已经达到阈值（buffer size * spill percent = 100MB * 0.8 = 80MB），溢写线程启动，锁定这80MB的内存，执行溢写过程。Map task的输出结果还可以往剩下的20MB内存中写，互不影响。\n> 　达到阈值以后溢写到磁盘上，排序用的是字典顺序的排序,排序的对象是序列化好的字节。最后溢写得到的多个文件根据hash值merge，也可以自定义combiner（可以理解为map端的reduce）），然后reduce开始fetch（拉取）map端合并好的数据，拉取来自不同map的相同分区的数据（相同key的数据）过来，然后在reduce端合并，此时在reduce端也会进行一次sort。\n\n![shuffer流程图](/ITWO/assets/mapreduce02.png)\n\n","slug":"mapredcue 温习","published":1,"date":"2017-09-29T02:07:15.624Z","updated":"2017-09-29T02:07:15.624Z","layout":"post","photos":[],"link":"","_id":"cj8p9xinl0008y8ztv26wcbuc","content":"<h2 id=\"需求背景：\"><a href=\"#需求背景：\" class=\"headerlink\" title=\"需求背景：\"></a>需求背景：</h2><blockquote>\n<p>做大数据有一段时间了，梳理下用到mapreduce的一些问题和解决方案。</p>\n</blockquote>\n<h2 id=\"mapreduce\"><a href=\"#mapreduce\" class=\"headerlink\" title=\"mapreduce\"></a>mapreduce</h2><blockquote>\n<p>mapreduce:顾名思义，map做映射，reduce做规约。<br>主要分以下步骤：<br>1.输入分块<br>2.map<br>3.shuffer<br>4.reduce</p>\n</blockquote>\n<p><img src=\"/ITWO/assets/mapreduce01.jpg\" alt=\"mapredcue流程图\"><br>重点是shuffer阶段</p>\n<h2 id=\"reduce个数的计算方法\"><a href=\"#reduce个数的计算方法\" class=\"headerlink\" title=\"reduce个数的计算方法:\"></a>reduce个数的计算方法:</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> bytes = Math.max(totalInputFileSize, bytesPerReducer);</div><div class=\"line\"><span class=\"keyword\">int</span> reducers = (<span class=\"keyword\">int</span>) Math.ceil(bytes / bytesPerReducer);</div><div class=\"line\">reducers = Math.max(<span class=\"number\">1</span>, reducers);</div><div class=\"line\">reducers = Math.min(maxReducers, reducers);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>　从计算逻辑可以看出该量由输入文件的大小以及设置的每个reduce可以处理的字节数大小决定．</p>\n<p>　map接受分块数据，然后使用默认的分区算法（对输入文件的kv中对key hash后再对reduce task数量取模(reduce个数的算法见前文)），再通过内存缓冲区进行排序．<br>　这个溢写是由单独线程来完成，不影响往缓冲区写map结果的线程。溢写线程启动时不应该阻止map的结果输出，所以整个缓冲区有个溢写的比例spill.percent。这个比例默认是0.8，也就是当缓冲区的数据已经达到阈值（buffer size <em> spill percent = 100MB </em> 0.8 = 80MB），溢写线程启动，锁定这80MB的内存，执行溢写过程。Map task的输出结果还可以往剩下的20MB内存中写，互不影响。<br>　达到阈值以后溢写到磁盘上，排序用的是字典顺序的排序,排序的对象是序列化好的字节。最后溢写得到的多个文件根据hash值merge，也可以自定义combiner（可以理解为map端的reduce）），然后reduce开始fetch（拉取）map端合并好的数据，拉取来自不同map的相同分区的数据（相同key的数据）过来，然后在reduce端合并，此时在reduce端也会进行一次sort。</p>\n</blockquote>\n<p><img src=\"/ITWO/assets/mapreduce02.png\" alt=\"shuffer流程图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景：\"><a href=\"#需求背景：\" class=\"headerlink\" title=\"需求背景：\"></a>需求背景：</h2><blockquote>\n<p>做大数据有一段时间了，梳理下用到mapreduce的一些问题和解决方案。</p>\n</blockquote>\n<h2 id=\"mapreduce\"><a href=\"#mapreduce\" class=\"headerlink\" title=\"mapreduce\"></a>mapreduce</h2><blockquote>\n<p>mapreduce:顾名思义，map做映射，reduce做规约。<br>主要分以下步骤：<br>1.输入分块<br>2.map<br>3.shuffer<br>4.reduce</p>\n</blockquote>\n<p><img src=\"/ITWO/assets/mapreduce01.jpg\" alt=\"mapredcue流程图\"><br>重点是shuffer阶段</p>\n<h2 id=\"reduce个数的计算方法\"><a href=\"#reduce个数的计算方法\" class=\"headerlink\" title=\"reduce个数的计算方法:\"></a>reduce个数的计算方法:</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> bytes = Math.max(totalInputFileSize, bytesPerReducer);</div><div class=\"line\"><span class=\"keyword\">int</span> reducers = (<span class=\"keyword\">int</span>) Math.ceil(bytes / bytesPerReducer);</div><div class=\"line\">reducers = Math.max(<span class=\"number\">1</span>, reducers);</div><div class=\"line\">reducers = Math.min(maxReducers, reducers);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>　从计算逻辑可以看出该量由输入文件的大小以及设置的每个reduce可以处理的字节数大小决定．</p>\n<p>　map接受分块数据，然后使用默认的分区算法（对输入文件的kv中对key hash后再对reduce task数量取模(reduce个数的算法见前文)），再通过内存缓冲区进行排序．<br>　这个溢写是由单独线程来完成，不影响往缓冲区写map结果的线程。溢写线程启动时不应该阻止map的结果输出，所以整个缓冲区有个溢写的比例spill.percent。这个比例默认是0.8，也就是当缓冲区的数据已经达到阈值（buffer size <em> spill percent = 100MB </em> 0.8 = 80MB），溢写线程启动，锁定这80MB的内存，执行溢写过程。Map task的输出结果还可以往剩下的20MB内存中写，互不影响。<br>　达到阈值以后溢写到磁盘上，排序用的是字典顺序的排序,排序的对象是序列化好的字节。最后溢写得到的多个文件根据hash值merge，也可以自定义combiner（可以理解为map端的reduce）），然后reduce开始fetch（拉取）map端合并好的数据，拉取来自不同map的相同分区的数据（相同key的数据）过来，然后在reduce端合并，此时在reduce端也会进行一次sort。</p>\n</blockquote>\n<p><img src=\"/ITWO/assets/mapreduce02.png\" alt=\"shuffer流程图\"></p>\n"},{"title":"mongo 中count的正确用法","date":"2017-10-13T01:54:35.000Z","_content":"\n## 需求背景:\n>统计大批量次的某个时间段内的记录数，第一次使用的是count(),但是慢的要死，最后回想起聚合里面可以另辟蹊径统计记录数，下面给出解决方案：\n\n## 解决方案:\n\n``` python\n# -*-coding:utf-8-*-  \n#!/usr/bin/env python  \nfrom pymongo import MongoClient\nimport datetime\nimport json\ndb = MongoClient('mongodb://localhost:27017/').tal\n\n\nstart = datetime.datetime.strptime('2017-09-01T','%Y-%m-%dT')\nend = datetime.datetime.strptime('2017-10-01T','%Y-%m-%dT')\n\npipeline = [\n     {\"$match\":{\"requestTime\":{\"$gte\":start,\"$lt\":end}}},\n     {\"$group\":{\"_id\":{\"uri\":\"null\"},\"count\":{\"$sum\":1}}}\n ]\nret_val = list(db.sysRequestWrapper.aggregate(pipeline))\nret_ditc = eval(json.dumps(ret_val[0], sort_keys=True))\nprint ret_ditc['count']\n\n```\n\n","source":"_posts/mongo-中count的正确用法.md","raw":"---\ntitle: mongo 中count的正确用法\ndate: 2017-10-13 09:54:35\ntags: python mongo count\n---\n\n## 需求背景:\n>统计大批量次的某个时间段内的记录数，第一次使用的是count(),但是慢的要死，最后回想起聚合里面可以另辟蹊径统计记录数，下面给出解决方案：\n\n## 解决方案:\n\n``` python\n# -*-coding:utf-8-*-  \n#!/usr/bin/env python  \nfrom pymongo import MongoClient\nimport datetime\nimport json\ndb = MongoClient('mongodb://localhost:27017/').tal\n\n\nstart = datetime.datetime.strptime('2017-09-01T','%Y-%m-%dT')\nend = datetime.datetime.strptime('2017-10-01T','%Y-%m-%dT')\n\npipeline = [\n     {\"$match\":{\"requestTime\":{\"$gte\":start,\"$lt\":end}}},\n     {\"$group\":{\"_id\":{\"uri\":\"null\"},\"count\":{\"$sum\":1}}}\n ]\nret_val = list(db.sysRequestWrapper.aggregate(pipeline))\nret_ditc = eval(json.dumps(ret_val[0], sort_keys=True))\nprint ret_ditc['count']\n\n```\n\n","slug":"mongo-中count的正确用法","published":1,"updated":"2017-10-13T01:59:53.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xinm0009y8ztw92kd5af","content":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>统计大批量次的某个时间段内的记录数，第一次使用的是count(),但是慢的要死，最后回想起聚合里面可以另辟蹊径统计记录数，下面给出解决方案：</p>\n</blockquote>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python  </span></div><div class=\"line\"><span class=\"keyword\">from</span> pymongo <span class=\"keyword\">import</span> MongoClient</div><div class=\"line\"><span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"keyword\">import</span> json</div><div class=\"line\">db = MongoClient(<span class=\"string\">'mongodb://localhost:27017/'</span>).tal</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">start = datetime.datetime.strptime(<span class=\"string\">'2017-09-01T'</span>,<span class=\"string\">'%Y-%m-%dT'</span>)</div><div class=\"line\">end = datetime.datetime.strptime(<span class=\"string\">'2017-10-01T'</span>,<span class=\"string\">'%Y-%m-%dT'</span>)</div><div class=\"line\"></div><div class=\"line\">pipeline = [</div><div class=\"line\">     &#123;<span class=\"string\">\"$match\"</span>:&#123;<span class=\"string\">\"requestTime\"</span>:&#123;<span class=\"string\">\"$gte\"</span>:start,<span class=\"string\">\"$lt\"</span>:end&#125;&#125;&#125;,</div><div class=\"line\">     &#123;<span class=\"string\">\"$group\"</span>:&#123;<span class=\"string\">\"_id\"</span>:&#123;<span class=\"string\">\"uri\"</span>:<span class=\"string\">\"null\"</span>&#125;,<span class=\"string\">\"count\"</span>:&#123;<span class=\"string\">\"$sum\"</span>:<span class=\"number\">1</span>&#125;&#125;&#125;</div><div class=\"line\"> ]</div><div class=\"line\">ret_val = list(db.sysRequestWrapper.aggregate(pipeline))</div><div class=\"line\">ret_ditc = eval(json.dumps(ret_val[<span class=\"number\">0</span>], sort_keys=<span class=\"keyword\">True</span>))</div><div class=\"line\"><span class=\"keyword\">print</span> ret_ditc[<span class=\"string\">'count'</span>]</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>统计大批量次的某个时间段内的记录数，第一次使用的是count(),但是慢的要死，最后回想起聚合里面可以另辟蹊径统计记录数，下面给出解决方案：</p>\n</blockquote>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python  </span></div><div class=\"line\"><span class=\"keyword\">from</span> pymongo <span class=\"keyword\">import</span> MongoClient</div><div class=\"line\"><span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"keyword\">import</span> json</div><div class=\"line\">db = MongoClient(<span class=\"string\">'mongodb://localhost:27017/'</span>).tal</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">start = datetime.datetime.strptime(<span class=\"string\">'2017-09-01T'</span>,<span class=\"string\">'%Y-%m-%dT'</span>)</div><div class=\"line\">end = datetime.datetime.strptime(<span class=\"string\">'2017-10-01T'</span>,<span class=\"string\">'%Y-%m-%dT'</span>)</div><div class=\"line\"></div><div class=\"line\">pipeline = [</div><div class=\"line\">     &#123;<span class=\"string\">\"$match\"</span>:&#123;<span class=\"string\">\"requestTime\"</span>:&#123;<span class=\"string\">\"$gte\"</span>:start,<span class=\"string\">\"$lt\"</span>:end&#125;&#125;&#125;,</div><div class=\"line\">     &#123;<span class=\"string\">\"$group\"</span>:&#123;<span class=\"string\">\"_id\"</span>:&#123;<span class=\"string\">\"uri\"</span>:<span class=\"string\">\"null\"</span>&#125;,<span class=\"string\">\"count\"</span>:&#123;<span class=\"string\">\"$sum\"</span>:<span class=\"number\">1</span>&#125;&#125;&#125;</div><div class=\"line\"> ]</div><div class=\"line\">ret_val = list(db.sysRequestWrapper.aggregate(pipeline))</div><div class=\"line\">ret_ditc = eval(json.dumps(ret_val[<span class=\"number\">0</span>], sort_keys=<span class=\"keyword\">True</span>))</div><div class=\"line\"><span class=\"keyword\">print</span> ret_ditc[<span class=\"string\">'count'</span>]</div></pre></td></tr></table></figure>\n"},{"title":"mongo 中实现带where的group by","date":"2017-10-09T07:23:24.000Z","_content":"## 需求背景:\n>需要在mongo中统计同一个时间段内各个账号的接口调用量．\n\n## 解决思路:\n>通常我们在关系型数据库中可以这么解决:\n\n``` sql\nselect account,count(1) from db.table where requestTime>='2017-10-01' and requestTime <'2017-10-08'\ngroup by account;\n```\n## 解决方案:\n>参照sql语句的思路，然后给出mongo中的解决方案\n\n``` json\ndb.sysRequestWrapper.aggregate([\n    {\"$match\":{requestTime:{$gte:ISODate(\"2017-10-01T00:00:00.000Z\"),$lt:ISODate(\"2017-10-19T00:00:00.000Z\")}}}, \n    {\"$group\":{_id:{account:\"$account\"},\"count\":{\"$sum\":1}}}\n]);\n```\n>ps:如果需要实现having count(*)>1 则你需要再在后面追加match,来实现对group by 聚合结果的过滤．\n``` json\ndb.sysRequestWrapper.aggregate([\n    {\"$match\":{requestTime:{$gte:ISODate(\"2017-10-01T00:00:00.000Z\"),$lt:ISODate(\"2017-10-19T00:00:00.000Z\")}}}, \n    {\"$group\":{_id:{account:\"$account\"},\"count\":{\"$sum\":1}}},\n\t{\"$match\":{\"count\":{\"$gt\": 1}}}\n]);\n\n```\n","source":"_posts/mongo-中实现带where的group-by.md","raw":"---\ntitle: mongo 中实现带where的group by\ndate: 2017-10-09 15:23:24\ntags: mongo groupby where\n---\n## 需求背景:\n>需要在mongo中统计同一个时间段内各个账号的接口调用量．\n\n## 解决思路:\n>通常我们在关系型数据库中可以这么解决:\n\n``` sql\nselect account,count(1) from db.table where requestTime>='2017-10-01' and requestTime <'2017-10-08'\ngroup by account;\n```\n## 解决方案:\n>参照sql语句的思路，然后给出mongo中的解决方案\n\n``` json\ndb.sysRequestWrapper.aggregate([\n    {\"$match\":{requestTime:{$gte:ISODate(\"2017-10-01T00:00:00.000Z\"),$lt:ISODate(\"2017-10-19T00:00:00.000Z\")}}}, \n    {\"$group\":{_id:{account:\"$account\"},\"count\":{\"$sum\":1}}}\n]);\n```\n>ps:如果需要实现having count(*)>1 则你需要再在后面追加match,来实现对group by 聚合结果的过滤．\n``` json\ndb.sysRequestWrapper.aggregate([\n    {\"$match\":{requestTime:{$gte:ISODate(\"2017-10-01T00:00:00.000Z\"),$lt:ISODate(\"2017-10-19T00:00:00.000Z\")}}}, \n    {\"$group\":{_id:{account:\"$account\"},\"count\":{\"$sum\":1}}},\n\t{\"$match\":{\"count\":{\"$gt\": 1}}}\n]);\n\n```\n","slug":"mongo-中实现带where的group-by","published":1,"updated":"2017-10-10T03:16:11.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xinn000by8zt731v9ru9","content":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>需要在mongo中统计同一个时间段内各个账号的接口调用量．</p>\n</blockquote>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路:\"></a>解决思路:</h2><blockquote>\n<p>通常我们在关系型数据库中可以这么解决:</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">account</span>,<span class=\"keyword\">count</span>(<span class=\"number\">1</span>) <span class=\"keyword\">from</span> db.table <span class=\"keyword\">where</span> requestTime&gt;=<span class=\"string\">'2017-10-01'</span> <span class=\"keyword\">and</span> requestTime &lt;<span class=\"string\">'2017-10-08'</span></div><div class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">account</span>;</div></pre></td></tr></table></figure>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><blockquote>\n<p>参照sql语句的思路，然后给出mongo中的解决方案</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.sysRequestWrapper.aggregate([</div><div class=\"line\">    &#123;\"$match\":&#123;requestTime:&#123;$gte:ISODate(\"2017-10-01T00:00:00.000Z\"),$lt:ISODate(\"2017-10-19T00:00:00.000Z\")&#125;&#125;&#125;, </div><div class=\"line\">    &#123;\"$group\":&#123;_id:&#123;account:\"$account\"&#125;,\"count\":&#123;\"$sum\":1&#125;&#125;&#125;</div><div class=\"line\">]);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>ps:如果需要实现having count(*)&gt;1 则你需要再在后面追加match,来实现对group by 聚合结果的过滤．<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.sysRequestWrapper.aggregate([</div><div class=\"line\">    &#123;\"$match\":&#123;requestTime:&#123;$gte:ISODate(\"2017-10-01T00:00:00.000Z\"),$lt:ISODate(\"2017-10-19T00:00:00.000Z\")&#125;&#125;&#125;, </div><div class=\"line\">    &#123;\"$group\":&#123;_id:&#123;account:\"$account\"&#125;,\"count\":&#123;\"$sum\":1&#125;&#125;&#125;,</div><div class=\"line\">\t&#123;<span class=\"attr\">\"$match\"</span>:&#123;<span class=\"attr\">\"count\"</span>:&#123;<span class=\"attr\">\"$gt\"</span>: <span class=\"number\">1</span>&#125;&#125;&#125;</div><div class=\"line\">]);</div></pre></td></tr></table></figure></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>需要在mongo中统计同一个时间段内各个账号的接口调用量．</p>\n</blockquote>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路:\"></a>解决思路:</h2><blockquote>\n<p>通常我们在关系型数据库中可以这么解决:</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">account</span>,<span class=\"keyword\">count</span>(<span class=\"number\">1</span>) <span class=\"keyword\">from</span> db.table <span class=\"keyword\">where</span> requestTime&gt;=<span class=\"string\">'2017-10-01'</span> <span class=\"keyword\">and</span> requestTime &lt;<span class=\"string\">'2017-10-08'</span></div><div class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">account</span>;</div></pre></td></tr></table></figure>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><blockquote>\n<p>参照sql语句的思路，然后给出mongo中的解决方案</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.sysRequestWrapper.aggregate([</div><div class=\"line\">    &#123;\"$match\":&#123;requestTime:&#123;$gte:ISODate(\"2017-10-01T00:00:00.000Z\"),$lt:ISODate(\"2017-10-19T00:00:00.000Z\")&#125;&#125;&#125;, </div><div class=\"line\">    &#123;\"$group\":&#123;_id:&#123;account:\"$account\"&#125;,\"count\":&#123;\"$sum\":1&#125;&#125;&#125;</div><div class=\"line\">]);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>ps:如果需要实现having count(*)&gt;1 则你需要再在后面追加match,来实现对group by 聚合结果的过滤．<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.sysRequestWrapper.aggregate([</div><div class=\"line\">    &#123;\"$match\":&#123;requestTime:&#123;$gte:ISODate(\"2017-10-01T00:00:00.000Z\"),$lt:ISODate(\"2017-10-19T00:00:00.000Z\")&#125;&#125;&#125;, </div><div class=\"line\">    &#123;\"$group\":&#123;_id:&#123;account:\"$account\"&#125;,\"count\":&#123;\"$sum\":1&#125;&#125;&#125;,</div><div class=\"line\">\t&#123;<span class=\"attr\">\"$match\"</span>:&#123;<span class=\"attr\">\"count\"</span>:&#123;<span class=\"attr\">\"$gt\"</span>: <span class=\"number\">1</span>&#125;&#125;&#125;</div><div class=\"line\">]);</div></pre></td></tr></table></figure></p>\n</blockquote>\n"},{"title":"python- 实现聚合（单机版和mapreduce版本）","date":"2017-10-10T07:56:56.000Z","_content":"\n## 需求背景:\n>公司接口国庆期间调用量比较大，领导想要统计下今年和去年国庆期间接口每天的调用量和当天接口的调用的平均耗时．\n\n## 需求分析\n>技术选型：选择了python\n>同时从需求中可以了解到涉及到时间差的运算，联想到以前用过python中的datetime模块中的timedelta（时间三角洲）．\n\n## 技术实现\n## 单一代码解决\n### 方法一: 使用panda series解决(此解决方案由同事提供)\n>代码如下：\n\n``` python\n#!/usr/bin/env python\n\"\"\"\n# -*- coding: utf-8 -*-\n\"\"\"\n\nimport pandas as pd\nimport datetime\ndata=pd.read_csv('1610.csv')\ndata['requestTime']=data['requestTime'].map(lambda x:x.replace('T',' '))\ndata['responseTime']=data['responseTime'].map(lambda x:x.replace('T',' '))\ndata['requestTime']=data['requestTime'].map(lambda x:x.replace('Z',''))\ndata['responseTime']=data['responseTime'].map(lambda x:x.replace('Z',''))\ndata['requestTime']=data['requestTime'].map(lambda x:x.replace('.',' '))\ndata['responseTime']=data['responseTime'].map(lambda x:x.replace('.',' '))\n\ndata['delta']=pd.Series(map(lambda x,y:(datetime.datetime.strptime(x,'%Y-%m-%d %H:%M:%S %f')-datetime.datetime.strptime(y,'%Y-%m-%d %H:%M:%S %f')).total_seconds()*1000,data['responseTime'],data['requestTime']))\ndata['date_day']=pd.Series(map(lambda x:x[:10],data['requestTime']))\ndata_out=data.groupby(['uri','date_day']).delta.agg(['mean','count','sum']).reset_index()\ndata_out.to_csv('16.csv',index=False)\n\n\n```\n\n\n###方法二： 纯map解决\n>这个是由两个时间的差值返回的,两个date或datetime对象相减时可以返回一个timedelta对象。\n>查看timedelta源码可以找到其中返回的有以下几个方法，如下图：\n\n![timedela中用到的方法](/ITWO/assets/timedela.png)\n>可以看出来，有很多有用的方法，可以求出两个时间的天数差，秒差，微秒差．\n>接口耗时我们需要的肯定是定位到毫秒即可，所以我们的解决方案是拿到微秒差然后除以1000转换为毫秒．\n\n``` python\ndef compare_time(sourceTime,reqtime):\n\tsourceTime = datetime.strptime(sourceTime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\treqtime = datetime.strptime(reqtime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\t#retval = (reqtime-sourceTime).microseconds/1000\n\treturn retval\n```\n>此处这么用只算到了微秒值，但是可能存在超过一秒的调用耗时，所以我们需要使用以下的方法来实现计算毫秒差值,此方法是python 2.7以后提供的，注意使用环境。\n\n``` python\ndef compare_time(sourceTime,reqtime):\n\tsourceTime = datetime.strptime(sourceTime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\treqtime = datetime.strptime(reqtime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\t#retval = (reqtime-sourceTime).microseconds/1000\n\tretval = (reqtime-sourceTime).total_seconds()*1000\n\treturn retval\n```\n\n>数据demo:/quota/usernature,2017-09-24T00:00:12.504Z,2017-09-24T00:00:12.628Z\n>继续分析:既然需要分析某天某个接口唯独的指标，则我们可以将uri和日期作为key，从demo中我们可以做到使用T作为分割符分割数据一次，就可以拿到我们想要的key，然后我们使用逗号分割，计算第二项和第三项的差值（取毫秒值）做为value，同时我们考虑到同一天同一个uri的调用量很多，所以肯定是vs,我们需要定义一个list存放多个时间差值，所以中间输出值为key,vs,eg:/quota/usernature,2017-09-24,[100,200,300.....]\n>然后需要做的是，遍历所有的key，当然为了方便查看，我们需要先将key排序，然后顺序查看，然后统计vs的长度，即为我们需要的该接口当天的调用量，使用list的sum函数统计总的耗时然后除以调用量就是我们需要的平均耗时。\n全部代码实现如下：\n\n``` python\n# -*-coding:utf-8-*-  \nimport sys\nfrom datetime import datetime\n\n\ndef compare_time(sourceTime,reqtime):\n\tsourceTime = datetime.strptime(sourceTime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\treqtime = datetime.strptime(reqtime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\tretval = (reqtime-sourceTime).microseconds/1000\n\treturn retval\n\n\ndef main(sep=\",\"):\n\tkv = {}\n\tvs = []\n\tfor line in sys.stdin:\n\t\tdetail = line.strip().split(sep)\n\t\trestime = detail[1]\n\t\treqtime = detail[2]\n\t\tvalue = compare_time(restime,reqtime)\n\t\tkey = line.strip().split(\"T\",1)[0].strip()\n\t\tif(key not in kv.keys()):\n\t\t\tvs=[]\n\t\t\tvs.append(value)\n\t\t\tkv[key] = vs\n\t\telse:\n\t\t\tvs.append(value)\n\t\t\tkv[key] = vs\n\tkeys = sorted(kv.keys())\n\tfor key in keys:\n\t\tcnt = len(kv[key])\n\t\tavgCnt = sum(kv[key])/cnt\n\t\tprint \"%s\\t%d\\t%f\" % (key,cnt,avgCnt)\n\n\nif __name__ == '__main__':\n\tmain()\n\n```\n此方法数据量大了有点问题，统计的有问题，还在磨合中，下面给出参考如下链接写出的mapreduce两个版本的脚本。\nhttp://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/\n\n### mapreduce版\n#### 方法一:使用mapreduce的特性\n>排序完使用，比较下一条和上一条的数据的key，累计调用耗时，以及次数最终的到结果。\n>map.py:\n\n``` python\n# -*-coding:utf-8-*-  \nimport sys\nfrom datetime import datetime\n\n\ndef compare_time(sourceTime,reqtime):\n\tsourceTime = datetime.strptime(sourceTime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\treqtime = datetime.strptime(reqtime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\tretval = (reqtime-sourceTime).total_seconds()*1000\n\treturn retval\n\n\ndef main(sep=\",\"):\n\tkv = {}\n\tfor line in sys.stdin:\n\t\tdetail = line.strip().split(sep)\n\t\trestime = detail[1]\n\t\treqtime = detail[2]\n\t\tvalue = compare_time(restime,reqtime)\n\t\tkey = line.strip().split(\"T\",1)[0]\n\t\tprint key+'\\t'+str(value)\n\n\n\n\nif __name__ == '__main__':\n\tmain()\n```\n\n>red.py\n\n``` python\n#!/usr/bin/env python  \n# -*-coding:utf-8-*-   \nimport sys  \n  \ncurrent_key = None  \ntotal_take = 0  \nkey = None\ntimes = 0  \none = 1\nfor line in sys.stdin:  \n    line = line.strip()  \n  \n    key, time_take = line.split('\\t', one)  \n    try:\n        time_take = float(time_take)  \n    except ValueError:  \n        #bad line pass \n        continue  \n    if current_key == key:  \n        total_take += time_take\n        times += one\n    else:\n        # if current_key ne next_key handle this logic and  print result,then init new key line data and init times\n        if current_key:  \n            print '%s\\t%s\\t%s' % (current_key,times,total_take/times)  \n        total_take = time_take  \n        current_key = key\n        times = one  \n\n# if stdin input over ,then handle this logic(there is no comparation after the last key compute ,so print here is necessary)\nif current_key == key:\n    print '%s\\t%s\\t%f' % (current_key,times,total_take/times) \n```\n#### 方法二　使用迭代器\n>同样也可以利用mapreduce中间的shuffle过程，map代码同上，reduce代码则使用yield生成迭代器同时配合groupby 工具函数来完成聚合。\n>reduce.py\n\n``` python\n# -*-coding:utf-8-*-  \n#!/usr/bin/env python  \n\nfrom itertools import groupby  \nfrom operator import itemgetter  \nimport sys  \n  \ndef read_mapper_output(file, separator='\\t'):  \n    for line in file:  \n        yield line.rstrip().split(separator, 1)  \n  \ndef main(separator='\\t'):  \n    data = read_mapper_output(sys.stdin, separator=separator)  \n    for current_word, group in groupby(data, itemgetter(0)):  \n        try:\n            # (float(count) for current_word,count in group)'s return is generator,if you want handle this twice,\n            # you should store　generator into one collection(here:list) ,if not the generator just can be used once,\n            # because the generator.next()(once used) had pointed to the end,can’t　be used more.\n            res_temp = list(float(count) for current_word,count in group)\n            size_count = sum(1 for _ in res_temp)\n            total_count = sum(res_temp)\n            print \"%s%s%d%s%f\" % (current_word, separator, size_count ,separator ,total_count/size_count)\n        except ValueError:  \n            pass  \n  \nif __name__ == \"__main__\":  \n    main()  \n```\n>以上两种mapreduce实现逻辑，我以用蹩脚的英文解释，看不懂，就使劲儿看。\n\n## 总结\n>mapreduce思想可以很自然的解决此类问题，但是也考虑到仅有map的情况下，怎么解决？但是这次写的代码还是存在问题，后续会解决更新。","source":"_posts/python-实现聚合（单机版和mapreduce版本）.md","raw":"---\ntitle: python- 实现聚合（单机版和mapreduce版本）\ndate: 2017-10-10 15:56:56\ntags: python date count sum aggr mean panda\n---\n\n## 需求背景:\n>公司接口国庆期间调用量比较大，领导想要统计下今年和去年国庆期间接口每天的调用量和当天接口的调用的平均耗时．\n\n## 需求分析\n>技术选型：选择了python\n>同时从需求中可以了解到涉及到时间差的运算，联想到以前用过python中的datetime模块中的timedelta（时间三角洲）．\n\n## 技术实现\n## 单一代码解决\n### 方法一: 使用panda series解决(此解决方案由同事提供)\n>代码如下：\n\n``` python\n#!/usr/bin/env python\n\"\"\"\n# -*- coding: utf-8 -*-\n\"\"\"\n\nimport pandas as pd\nimport datetime\ndata=pd.read_csv('1610.csv')\ndata['requestTime']=data['requestTime'].map(lambda x:x.replace('T',' '))\ndata['responseTime']=data['responseTime'].map(lambda x:x.replace('T',' '))\ndata['requestTime']=data['requestTime'].map(lambda x:x.replace('Z',''))\ndata['responseTime']=data['responseTime'].map(lambda x:x.replace('Z',''))\ndata['requestTime']=data['requestTime'].map(lambda x:x.replace('.',' '))\ndata['responseTime']=data['responseTime'].map(lambda x:x.replace('.',' '))\n\ndata['delta']=pd.Series(map(lambda x,y:(datetime.datetime.strptime(x,'%Y-%m-%d %H:%M:%S %f')-datetime.datetime.strptime(y,'%Y-%m-%d %H:%M:%S %f')).total_seconds()*1000,data['responseTime'],data['requestTime']))\ndata['date_day']=pd.Series(map(lambda x:x[:10],data['requestTime']))\ndata_out=data.groupby(['uri','date_day']).delta.agg(['mean','count','sum']).reset_index()\ndata_out.to_csv('16.csv',index=False)\n\n\n```\n\n\n###方法二： 纯map解决\n>这个是由两个时间的差值返回的,两个date或datetime对象相减时可以返回一个timedelta对象。\n>查看timedelta源码可以找到其中返回的有以下几个方法，如下图：\n\n![timedela中用到的方法](/ITWO/assets/timedela.png)\n>可以看出来，有很多有用的方法，可以求出两个时间的天数差，秒差，微秒差．\n>接口耗时我们需要的肯定是定位到毫秒即可，所以我们的解决方案是拿到微秒差然后除以1000转换为毫秒．\n\n``` python\ndef compare_time(sourceTime,reqtime):\n\tsourceTime = datetime.strptime(sourceTime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\treqtime = datetime.strptime(reqtime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\t#retval = (reqtime-sourceTime).microseconds/1000\n\treturn retval\n```\n>此处这么用只算到了微秒值，但是可能存在超过一秒的调用耗时，所以我们需要使用以下的方法来实现计算毫秒差值,此方法是python 2.7以后提供的，注意使用环境。\n\n``` python\ndef compare_time(sourceTime,reqtime):\n\tsourceTime = datetime.strptime(sourceTime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\treqtime = datetime.strptime(reqtime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\t#retval = (reqtime-sourceTime).microseconds/1000\n\tretval = (reqtime-sourceTime).total_seconds()*1000\n\treturn retval\n```\n\n>数据demo:/quota/usernature,2017-09-24T00:00:12.504Z,2017-09-24T00:00:12.628Z\n>继续分析:既然需要分析某天某个接口唯独的指标，则我们可以将uri和日期作为key，从demo中我们可以做到使用T作为分割符分割数据一次，就可以拿到我们想要的key，然后我们使用逗号分割，计算第二项和第三项的差值（取毫秒值）做为value，同时我们考虑到同一天同一个uri的调用量很多，所以肯定是vs,我们需要定义一个list存放多个时间差值，所以中间输出值为key,vs,eg:/quota/usernature,2017-09-24,[100,200,300.....]\n>然后需要做的是，遍历所有的key，当然为了方便查看，我们需要先将key排序，然后顺序查看，然后统计vs的长度，即为我们需要的该接口当天的调用量，使用list的sum函数统计总的耗时然后除以调用量就是我们需要的平均耗时。\n全部代码实现如下：\n\n``` python\n# -*-coding:utf-8-*-  \nimport sys\nfrom datetime import datetime\n\n\ndef compare_time(sourceTime,reqtime):\n\tsourceTime = datetime.strptime(sourceTime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\treqtime = datetime.strptime(reqtime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\tretval = (reqtime-sourceTime).microseconds/1000\n\treturn retval\n\n\ndef main(sep=\",\"):\n\tkv = {}\n\tvs = []\n\tfor line in sys.stdin:\n\t\tdetail = line.strip().split(sep)\n\t\trestime = detail[1]\n\t\treqtime = detail[2]\n\t\tvalue = compare_time(restime,reqtime)\n\t\tkey = line.strip().split(\"T\",1)[0].strip()\n\t\tif(key not in kv.keys()):\n\t\t\tvs=[]\n\t\t\tvs.append(value)\n\t\t\tkv[key] = vs\n\t\telse:\n\t\t\tvs.append(value)\n\t\t\tkv[key] = vs\n\tkeys = sorted(kv.keys())\n\tfor key in keys:\n\t\tcnt = len(kv[key])\n\t\tavgCnt = sum(kv[key])/cnt\n\t\tprint \"%s\\t%d\\t%f\" % (key,cnt,avgCnt)\n\n\nif __name__ == '__main__':\n\tmain()\n\n```\n此方法数据量大了有点问题，统计的有问题，还在磨合中，下面给出参考如下链接写出的mapreduce两个版本的脚本。\nhttp://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/\n\n### mapreduce版\n#### 方法一:使用mapreduce的特性\n>排序完使用，比较下一条和上一条的数据的key，累计调用耗时，以及次数最终的到结果。\n>map.py:\n\n``` python\n# -*-coding:utf-8-*-  \nimport sys\nfrom datetime import datetime\n\n\ndef compare_time(sourceTime,reqtime):\n\tsourceTime = datetime.strptime(sourceTime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\treqtime = datetime.strptime(reqtime.replace('T',' ').replace(\"Z\",''),\"%Y-%m-%d %H:%M:%S.%f\")\n\tretval = (reqtime-sourceTime).total_seconds()*1000\n\treturn retval\n\n\ndef main(sep=\",\"):\n\tkv = {}\n\tfor line in sys.stdin:\n\t\tdetail = line.strip().split(sep)\n\t\trestime = detail[1]\n\t\treqtime = detail[2]\n\t\tvalue = compare_time(restime,reqtime)\n\t\tkey = line.strip().split(\"T\",1)[0]\n\t\tprint key+'\\t'+str(value)\n\n\n\n\nif __name__ == '__main__':\n\tmain()\n```\n\n>red.py\n\n``` python\n#!/usr/bin/env python  \n# -*-coding:utf-8-*-   \nimport sys  \n  \ncurrent_key = None  \ntotal_take = 0  \nkey = None\ntimes = 0  \none = 1\nfor line in sys.stdin:  \n    line = line.strip()  \n  \n    key, time_take = line.split('\\t', one)  \n    try:\n        time_take = float(time_take)  \n    except ValueError:  \n        #bad line pass \n        continue  \n    if current_key == key:  \n        total_take += time_take\n        times += one\n    else:\n        # if current_key ne next_key handle this logic and  print result,then init new key line data and init times\n        if current_key:  \n            print '%s\\t%s\\t%s' % (current_key,times,total_take/times)  \n        total_take = time_take  \n        current_key = key\n        times = one  \n\n# if stdin input over ,then handle this logic(there is no comparation after the last key compute ,so print here is necessary)\nif current_key == key:\n    print '%s\\t%s\\t%f' % (current_key,times,total_take/times) \n```\n#### 方法二　使用迭代器\n>同样也可以利用mapreduce中间的shuffle过程，map代码同上，reduce代码则使用yield生成迭代器同时配合groupby 工具函数来完成聚合。\n>reduce.py\n\n``` python\n# -*-coding:utf-8-*-  \n#!/usr/bin/env python  \n\nfrom itertools import groupby  \nfrom operator import itemgetter  \nimport sys  \n  \ndef read_mapper_output(file, separator='\\t'):  \n    for line in file:  \n        yield line.rstrip().split(separator, 1)  \n  \ndef main(separator='\\t'):  \n    data = read_mapper_output(sys.stdin, separator=separator)  \n    for current_word, group in groupby(data, itemgetter(0)):  \n        try:\n            # (float(count) for current_word,count in group)'s return is generator,if you want handle this twice,\n            # you should store　generator into one collection(here:list) ,if not the generator just can be used once,\n            # because the generator.next()(once used) had pointed to the end,can’t　be used more.\n            res_temp = list(float(count) for current_word,count in group)\n            size_count = sum(1 for _ in res_temp)\n            total_count = sum(res_temp)\n            print \"%s%s%d%s%f\" % (current_word, separator, size_count ,separator ,total_count/size_count)\n        except ValueError:  \n            pass  \n  \nif __name__ == \"__main__\":  \n    main()  \n```\n>以上两种mapreduce实现逻辑，我以用蹩脚的英文解释，看不懂，就使劲儿看。\n\n## 总结\n>mapreduce思想可以很自然的解决此类问题，但是也考虑到仅有map的情况下，怎么解决？但是这次写的代码还是存在问题，后续会解决更新。","slug":"python-实现聚合（单机版和mapreduce版本）","published":1,"updated":"2017-10-12T02:31:11.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xinp000dy8zt2a61msc1","content":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>公司接口国庆期间调用量比较大，领导想要统计下今年和去年国庆期间接口每天的调用量和当天接口的调用的平均耗时．</p>\n</blockquote>\n<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><blockquote>\n<p>技术选型：选择了python<br>同时从需求中可以了解到涉及到时间差的运算，联想到以前用过python中的datetime模块中的timedelta（时间三角洲）．</p>\n</blockquote>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><h2 id=\"单一代码解决\"><a href=\"#单一代码解决\" class=\"headerlink\" title=\"单一代码解决\"></a>单一代码解决</h2><h3 id=\"方法一-使用panda-series解决-此解决方案由同事提供\"><a href=\"#方法一-使用panda-series解决-此解决方案由同事提供\" class=\"headerlink\" title=\"方法一: 使用panda series解决(此解决方案由同事提供)\"></a>方法一: 使用panda series解决(此解决方案由同事提供)</h3><blockquote>\n<p>代码如下：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\"><span class=\"string\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</div><div class=\"line\"><span class=\"keyword\">import</span> datetime</div><div class=\"line\">data=pd.read_csv(<span class=\"string\">'1610.csv'</span>)</div><div class=\"line\">data[<span class=\"string\">'requestTime'</span>]=data[<span class=\"string\">'requestTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>))</div><div class=\"line\">data[<span class=\"string\">'responseTime'</span>]=data[<span class=\"string\">'responseTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>))</div><div class=\"line\">data[<span class=\"string\">'requestTime'</span>]=data[<span class=\"string\">'requestTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'Z'</span>,<span class=\"string\">''</span>))</div><div class=\"line\">data[<span class=\"string\">'responseTime'</span>]=data[<span class=\"string\">'responseTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'Z'</span>,<span class=\"string\">''</span>))</div><div class=\"line\">data[<span class=\"string\">'requestTime'</span>]=data[<span class=\"string\">'requestTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'.'</span>,<span class=\"string\">' '</span>))</div><div class=\"line\">data[<span class=\"string\">'responseTime'</span>]=data[<span class=\"string\">'responseTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'.'</span>,<span class=\"string\">' '</span>))</div><div class=\"line\"></div><div class=\"line\">data[<span class=\"string\">'delta'</span>]=pd.Series(map(<span class=\"keyword\">lambda</span> x,y:(datetime.datetime.strptime(x,<span class=\"string\">'%Y-%m-%d %H:%M:%S %f'</span>)-datetime.datetime.strptime(y,<span class=\"string\">'%Y-%m-%d %H:%M:%S %f'</span>)).total_seconds()*<span class=\"number\">1000</span>,data[<span class=\"string\">'responseTime'</span>],data[<span class=\"string\">'requestTime'</span>]))</div><div class=\"line\">data[<span class=\"string\">'date_day'</span>]=pd.Series(map(<span class=\"keyword\">lambda</span> x:x[:<span class=\"number\">10</span>],data[<span class=\"string\">'requestTime'</span>]))</div><div class=\"line\">data_out=data.groupby([<span class=\"string\">'uri'</span>,<span class=\"string\">'date_day'</span>]).delta.agg([<span class=\"string\">'mean'</span>,<span class=\"string\">'count'</span>,<span class=\"string\">'sum'</span>]).reset_index()</div><div class=\"line\">data_out.to_csv(<span class=\"string\">'16.csv'</span>,index=<span class=\"keyword\">False</span>)</div></pre></td></tr></table></figure>\n<p>###方法二： 纯map解决</p>\n<blockquote>\n<p>这个是由两个时间的差值返回的,两个date或datetime对象相减时可以返回一个timedelta对象。<br>查看timedelta源码可以找到其中返回的有以下几个方法，如下图：</p>\n</blockquote>\n<p><img src=\"/ITWO/assets/timedela.png\" alt=\"timedela中用到的方法\"></p>\n<blockquote>\n<p>可以看出来，有很多有用的方法，可以求出两个时间的天数差，秒差，微秒差．<br>接口耗时我们需要的肯定是定位到毫秒即可，所以我们的解决方案是拿到微秒差然后除以1000转换为毫秒．</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare_time</span><span class=\"params\">(sourceTime,reqtime)</span>:</span></div><div class=\"line\">\tsourceTime = datetime.strptime(sourceTime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\treqtime = datetime.strptime(reqtime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\t<span class=\"comment\">#retval = (reqtime-sourceTime).microseconds/1000</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> retval</div></pre></td></tr></table></figure>\n<blockquote>\n<p>此处这么用只算到了微秒值，但是可能存在超过一秒的调用耗时，所以我们需要使用以下的方法来实现计算毫秒差值,此方法是python 2.7以后提供的，注意使用环境。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare_time</span><span class=\"params\">(sourceTime,reqtime)</span>:</span></div><div class=\"line\">\tsourceTime = datetime.strptime(sourceTime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\treqtime = datetime.strptime(reqtime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\t<span class=\"comment\">#retval = (reqtime-sourceTime).microseconds/1000</span></div><div class=\"line\">\tretval = (reqtime-sourceTime).total_seconds()*<span class=\"number\">1000</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> retval</div></pre></td></tr></table></figure>\n<blockquote>\n<p>数据demo:/quota/usernature,2017-09-24T00:00:12.504Z,2017-09-24T00:00:12.628Z<br>继续分析:既然需要分析某天某个接口唯独的指标，则我们可以将uri和日期作为key，从demo中我们可以做到使用T作为分割符分割数据一次，就可以拿到我们想要的key，然后我们使用逗号分割，计算第二项和第三项的差值（取毫秒值）做为value，同时我们考虑到同一天同一个uri的调用量很多，所以肯定是vs,我们需要定义一个list存放多个时间差值，所以中间输出值为key,vs,eg:/quota/usernature,2017-09-24,[100,200,300…..]<br>然后需要做的是，遍历所有的key，当然为了方便查看，我们需要先将key排序，然后顺序查看，然后统计vs的长度，即为我们需要的该接口当天的调用量，使用list的sum函数统计总的耗时然后除以调用量就是我们需要的平均耗时。<br>全部代码实现如下：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare_time</span><span class=\"params\">(sourceTime,reqtime)</span>:</span></div><div class=\"line\">\tsourceTime = datetime.strptime(sourceTime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\treqtime = datetime.strptime(reqtime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\tretval = (reqtime-sourceTime).microseconds/<span class=\"number\">1000</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> retval</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">(sep=<span class=\"string\">\",\"</span>)</span>:</span></div><div class=\"line\">\tkv = &#123;&#125;</div><div class=\"line\">\tvs = []</div><div class=\"line\">\t<span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:</div><div class=\"line\">\t\tdetail = line.strip().split(sep)</div><div class=\"line\">\t\trestime = detail[<span class=\"number\">1</span>]</div><div class=\"line\">\t\treqtime = detail[<span class=\"number\">2</span>]</div><div class=\"line\">\t\tvalue = compare_time(restime,reqtime)</div><div class=\"line\">\t\tkey = line.strip().split(<span class=\"string\">\"T\"</span>,<span class=\"number\">1</span>)[<span class=\"number\">0</span>].strip()</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(key <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> kv.keys()):</div><div class=\"line\">\t\t\tvs=[]</div><div class=\"line\">\t\t\tvs.append(value)</div><div class=\"line\">\t\t\tkv[key] = vs</div><div class=\"line\">\t\t<span class=\"keyword\">else</span>:</div><div class=\"line\">\t\t\tvs.append(value)</div><div class=\"line\">\t\t\tkv[key] = vs</div><div class=\"line\">\tkeys = sorted(kv.keys())</div><div class=\"line\">\t<span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> keys:</div><div class=\"line\">\t\tcnt = len(kv[key])</div><div class=\"line\">\t\tavgCnt = sum(kv[key])/cnt</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> <span class=\"string\">\"%s\\t%d\\t%f\"</span> % (key,cnt,avgCnt)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">\tmain()</div></pre></td></tr></table></figure>\n<p>此方法数据量大了有点问题，统计的有问题，还在磨合中，下面给出参考如下链接写出的mapreduce两个版本的脚本。<br><a href=\"http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/\" target=\"_blank\" rel=\"external\">http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/</a></p>\n<h3 id=\"mapreduce版\"><a href=\"#mapreduce版\" class=\"headerlink\" title=\"mapreduce版\"></a>mapreduce版</h3><h4 id=\"方法一-使用mapreduce的特性\"><a href=\"#方法一-使用mapreduce的特性\" class=\"headerlink\" title=\"方法一:使用mapreduce的特性\"></a>方法一:使用mapreduce的特性</h4><blockquote>\n<p>排序完使用，比较下一条和上一条的数据的key，累计调用耗时，以及次数最终的到结果。<br>map.py:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare_time</span><span class=\"params\">(sourceTime,reqtime)</span>:</span></div><div class=\"line\">\tsourceTime = datetime.strptime(sourceTime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\treqtime = datetime.strptime(reqtime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\tretval = (reqtime-sourceTime).total_seconds()*<span class=\"number\">1000</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> retval</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">(sep=<span class=\"string\">\",\"</span>)</span>:</span></div><div class=\"line\">\tkv = &#123;&#125;</div><div class=\"line\">\t<span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:</div><div class=\"line\">\t\tdetail = line.strip().split(sep)</div><div class=\"line\">\t\trestime = detail[<span class=\"number\">1</span>]</div><div class=\"line\">\t\treqtime = detail[<span class=\"number\">2</span>]</div><div class=\"line\">\t\tvalue = compare_time(restime,reqtime)</div><div class=\"line\">\t\tkey = line.strip().split(<span class=\"string\">\"T\"</span>,<span class=\"number\">1</span>)[<span class=\"number\">0</span>]</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> key+<span class=\"string\">'\\t'</span>+str(value)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">\tmain()</div></pre></td></tr></table></figure>\n<blockquote>\n<p>red.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python  </span></div><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-   </span></div><div class=\"line\"><span class=\"keyword\">import</span> sys  </div><div class=\"line\">  </div><div class=\"line\">current_key = <span class=\"keyword\">None</span>  </div><div class=\"line\">total_take = <span class=\"number\">0</span>  </div><div class=\"line\">key = <span class=\"keyword\">None</span></div><div class=\"line\">times = <span class=\"number\">0</span>  </div><div class=\"line\">one = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:  </div><div class=\"line\">    line = line.strip()  </div><div class=\"line\">  </div><div class=\"line\">    key, time_take = line.split(<span class=\"string\">'\\t'</span>, one)  </div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        time_take = float(time_take)  </div><div class=\"line\">    <span class=\"keyword\">except</span> ValueError:  </div><div class=\"line\">        <span class=\"comment\">#bad line pass </span></div><div class=\"line\">        <span class=\"keyword\">continue</span>  </div><div class=\"line\">    <span class=\"keyword\">if</span> current_key == key:  </div><div class=\"line\">        total_take += time_take</div><div class=\"line\">        times += one</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"comment\"># if current_key ne next_key handle this logic and  print result,then init new key line data and init times</span></div><div class=\"line\">        <span class=\"keyword\">if</span> current_key:  </div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">'%s\\t%s\\t%s'</span> % (current_key,times,total_take/times)  </div><div class=\"line\">        total_take = time_take  </div><div class=\"line\">        current_key = key</div><div class=\"line\">        times = one  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># if stdin input over ,then handle this logic(there is no comparation after the last key compute ,so print here is necessary)</span></div><div class=\"line\"><span class=\"keyword\">if</span> current_key == key:</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'%s\\t%s\\t%f'</span> % (current_key,times,total_take/times)</div></pre></td></tr></table></figure>\n<h4 id=\"方法二-使用迭代器\"><a href=\"#方法二-使用迭代器\" class=\"headerlink\" title=\"方法二　使用迭代器\"></a>方法二　使用迭代器</h4><blockquote>\n<p>同样也可以利用mapreduce中间的shuffle过程，map代码同上，reduce代码则使用yield生成迭代器同时配合groupby 工具函数来完成聚合。<br>reduce.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python  </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> groupby  </div><div class=\"line\"><span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> itemgetter  </div><div class=\"line\"><span class=\"keyword\">import</span> sys  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_mapper_output</span><span class=\"params\">(file, separator=<span class=\"string\">'\\t'</span>)</span>:</span>  </div><div class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> file:  </div><div class=\"line\">        <span class=\"keyword\">yield</span> line.rstrip().split(separator, <span class=\"number\">1</span>)  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">(separator=<span class=\"string\">'\\t'</span>)</span>:</span>  </div><div class=\"line\">    data = read_mapper_output(sys.stdin, separator=separator)  </div><div class=\"line\">    <span class=\"keyword\">for</span> current_word, group <span class=\"keyword\">in</span> groupby(data, itemgetter(<span class=\"number\">0</span>)):  </div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"comment\"># (float(count) for current_word,count in group)'s return is generator,if you want handle this twice,</span></div><div class=\"line\">            <span class=\"comment\"># you should store　generator into one collection(here:list) ,if not the generator just can be used once,</span></div><div class=\"line\">            <span class=\"comment\"># because the generator.next()(once used) had pointed to the end,can’t　be used more.</span></div><div class=\"line\">            res_temp = list(float(count) <span class=\"keyword\">for</span> current_word,count <span class=\"keyword\">in</span> group)</div><div class=\"line\">            size_count = sum(<span class=\"number\">1</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> res_temp)</div><div class=\"line\">            total_count = sum(res_temp)</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"%s%s%d%s%f\"</span> % (current_word, separator, size_count ,separator ,total_count/size_count)</div><div class=\"line\">        <span class=\"keyword\">except</span> ValueError:  </div><div class=\"line\">            <span class=\"keyword\">pass</span>  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:  </div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<blockquote>\n<p>以上两种mapreduce实现逻辑，我以用蹩脚的英文解释，看不懂，就使劲儿看。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p>mapreduce思想可以很自然的解决此类问题，但是也考虑到仅有map的情况下，怎么解决？但是这次写的代码还是存在问题，后续会解决更新。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>公司接口国庆期间调用量比较大，领导想要统计下今年和去年国庆期间接口每天的调用量和当天接口的调用的平均耗时．</p>\n</blockquote>\n<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><blockquote>\n<p>技术选型：选择了python<br>同时从需求中可以了解到涉及到时间差的运算，联想到以前用过python中的datetime模块中的timedelta（时间三角洲）．</p>\n</blockquote>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><h2 id=\"单一代码解决\"><a href=\"#单一代码解决\" class=\"headerlink\" title=\"单一代码解决\"></a>单一代码解决</h2><h3 id=\"方法一-使用panda-series解决-此解决方案由同事提供\"><a href=\"#方法一-使用panda-series解决-此解决方案由同事提供\" class=\"headerlink\" title=\"方法一: 使用panda series解决(此解决方案由同事提供)\"></a>方法一: 使用panda series解决(此解决方案由同事提供)</h3><blockquote>\n<p>代码如下：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\"><span class=\"string\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</div><div class=\"line\"><span class=\"keyword\">import</span> datetime</div><div class=\"line\">data=pd.read_csv(<span class=\"string\">'1610.csv'</span>)</div><div class=\"line\">data[<span class=\"string\">'requestTime'</span>]=data[<span class=\"string\">'requestTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>))</div><div class=\"line\">data[<span class=\"string\">'responseTime'</span>]=data[<span class=\"string\">'responseTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>))</div><div class=\"line\">data[<span class=\"string\">'requestTime'</span>]=data[<span class=\"string\">'requestTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'Z'</span>,<span class=\"string\">''</span>))</div><div class=\"line\">data[<span class=\"string\">'responseTime'</span>]=data[<span class=\"string\">'responseTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'Z'</span>,<span class=\"string\">''</span>))</div><div class=\"line\">data[<span class=\"string\">'requestTime'</span>]=data[<span class=\"string\">'requestTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'.'</span>,<span class=\"string\">' '</span>))</div><div class=\"line\">data[<span class=\"string\">'responseTime'</span>]=data[<span class=\"string\">'responseTime'</span>].map(<span class=\"keyword\">lambda</span> x:x.replace(<span class=\"string\">'.'</span>,<span class=\"string\">' '</span>))</div><div class=\"line\"></div><div class=\"line\">data[<span class=\"string\">'delta'</span>]=pd.Series(map(<span class=\"keyword\">lambda</span> x,y:(datetime.datetime.strptime(x,<span class=\"string\">'%Y-%m-%d %H:%M:%S %f'</span>)-datetime.datetime.strptime(y,<span class=\"string\">'%Y-%m-%d %H:%M:%S %f'</span>)).total_seconds()*<span class=\"number\">1000</span>,data[<span class=\"string\">'responseTime'</span>],data[<span class=\"string\">'requestTime'</span>]))</div><div class=\"line\">data[<span class=\"string\">'date_day'</span>]=pd.Series(map(<span class=\"keyword\">lambda</span> x:x[:<span class=\"number\">10</span>],data[<span class=\"string\">'requestTime'</span>]))</div><div class=\"line\">data_out=data.groupby([<span class=\"string\">'uri'</span>,<span class=\"string\">'date_day'</span>]).delta.agg([<span class=\"string\">'mean'</span>,<span class=\"string\">'count'</span>,<span class=\"string\">'sum'</span>]).reset_index()</div><div class=\"line\">data_out.to_csv(<span class=\"string\">'16.csv'</span>,index=<span class=\"keyword\">False</span>)</div></pre></td></tr></table></figure>\n<p>###方法二： 纯map解决</p>\n<blockquote>\n<p>这个是由两个时间的差值返回的,两个date或datetime对象相减时可以返回一个timedelta对象。<br>查看timedelta源码可以找到其中返回的有以下几个方法，如下图：</p>\n</blockquote>\n<p><img src=\"/ITWO/assets/timedela.png\" alt=\"timedela中用到的方法\"></p>\n<blockquote>\n<p>可以看出来，有很多有用的方法，可以求出两个时间的天数差，秒差，微秒差．<br>接口耗时我们需要的肯定是定位到毫秒即可，所以我们的解决方案是拿到微秒差然后除以1000转换为毫秒．</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare_time</span><span class=\"params\">(sourceTime,reqtime)</span>:</span></div><div class=\"line\">\tsourceTime = datetime.strptime(sourceTime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\treqtime = datetime.strptime(reqtime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\t<span class=\"comment\">#retval = (reqtime-sourceTime).microseconds/1000</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> retval</div></pre></td></tr></table></figure>\n<blockquote>\n<p>此处这么用只算到了微秒值，但是可能存在超过一秒的调用耗时，所以我们需要使用以下的方法来实现计算毫秒差值,此方法是python 2.7以后提供的，注意使用环境。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare_time</span><span class=\"params\">(sourceTime,reqtime)</span>:</span></div><div class=\"line\">\tsourceTime = datetime.strptime(sourceTime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\treqtime = datetime.strptime(reqtime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\t<span class=\"comment\">#retval = (reqtime-sourceTime).microseconds/1000</span></div><div class=\"line\">\tretval = (reqtime-sourceTime).total_seconds()*<span class=\"number\">1000</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> retval</div></pre></td></tr></table></figure>\n<blockquote>\n<p>数据demo:/quota/usernature,2017-09-24T00:00:12.504Z,2017-09-24T00:00:12.628Z<br>继续分析:既然需要分析某天某个接口唯独的指标，则我们可以将uri和日期作为key，从demo中我们可以做到使用T作为分割符分割数据一次，就可以拿到我们想要的key，然后我们使用逗号分割，计算第二项和第三项的差值（取毫秒值）做为value，同时我们考虑到同一天同一个uri的调用量很多，所以肯定是vs,我们需要定义一个list存放多个时间差值，所以中间输出值为key,vs,eg:/quota/usernature,2017-09-24,[100,200,300…..]<br>然后需要做的是，遍历所有的key，当然为了方便查看，我们需要先将key排序，然后顺序查看，然后统计vs的长度，即为我们需要的该接口当天的调用量，使用list的sum函数统计总的耗时然后除以调用量就是我们需要的平均耗时。<br>全部代码实现如下：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare_time</span><span class=\"params\">(sourceTime,reqtime)</span>:</span></div><div class=\"line\">\tsourceTime = datetime.strptime(sourceTime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\treqtime = datetime.strptime(reqtime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\tretval = (reqtime-sourceTime).microseconds/<span class=\"number\">1000</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> retval</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">(sep=<span class=\"string\">\",\"</span>)</span>:</span></div><div class=\"line\">\tkv = &#123;&#125;</div><div class=\"line\">\tvs = []</div><div class=\"line\">\t<span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:</div><div class=\"line\">\t\tdetail = line.strip().split(sep)</div><div class=\"line\">\t\trestime = detail[<span class=\"number\">1</span>]</div><div class=\"line\">\t\treqtime = detail[<span class=\"number\">2</span>]</div><div class=\"line\">\t\tvalue = compare_time(restime,reqtime)</div><div class=\"line\">\t\tkey = line.strip().split(<span class=\"string\">\"T\"</span>,<span class=\"number\">1</span>)[<span class=\"number\">0</span>].strip()</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(key <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> kv.keys()):</div><div class=\"line\">\t\t\tvs=[]</div><div class=\"line\">\t\t\tvs.append(value)</div><div class=\"line\">\t\t\tkv[key] = vs</div><div class=\"line\">\t\t<span class=\"keyword\">else</span>:</div><div class=\"line\">\t\t\tvs.append(value)</div><div class=\"line\">\t\t\tkv[key] = vs</div><div class=\"line\">\tkeys = sorted(kv.keys())</div><div class=\"line\">\t<span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> keys:</div><div class=\"line\">\t\tcnt = len(kv[key])</div><div class=\"line\">\t\tavgCnt = sum(kv[key])/cnt</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> <span class=\"string\">\"%s\\t%d\\t%f\"</span> % (key,cnt,avgCnt)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">\tmain()</div></pre></td></tr></table></figure>\n<p>此方法数据量大了有点问题，统计的有问题，还在磨合中，下面给出参考如下链接写出的mapreduce两个版本的脚本。<br><a href=\"http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/\" target=\"_blank\" rel=\"external\">http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/</a></p>\n<h3 id=\"mapreduce版\"><a href=\"#mapreduce版\" class=\"headerlink\" title=\"mapreduce版\"></a>mapreduce版</h3><h4 id=\"方法一-使用mapreduce的特性\"><a href=\"#方法一-使用mapreduce的特性\" class=\"headerlink\" title=\"方法一:使用mapreduce的特性\"></a>方法一:使用mapreduce的特性</h4><blockquote>\n<p>排序完使用，比较下一条和上一条的数据的key，累计调用耗时，以及次数最终的到结果。<br>map.py:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compare_time</span><span class=\"params\">(sourceTime,reqtime)</span>:</span></div><div class=\"line\">\tsourceTime = datetime.strptime(sourceTime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\treqtime = datetime.strptime(reqtime.replace(<span class=\"string\">'T'</span>,<span class=\"string\">' '</span>).replace(<span class=\"string\">\"Z\"</span>,<span class=\"string\">''</span>),<span class=\"string\">\"%Y-%m-%d %H:%M:%S.%f\"</span>)</div><div class=\"line\">\tretval = (reqtime-sourceTime).total_seconds()*<span class=\"number\">1000</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> retval</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">(sep=<span class=\"string\">\",\"</span>)</span>:</span></div><div class=\"line\">\tkv = &#123;&#125;</div><div class=\"line\">\t<span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:</div><div class=\"line\">\t\tdetail = line.strip().split(sep)</div><div class=\"line\">\t\trestime = detail[<span class=\"number\">1</span>]</div><div class=\"line\">\t\treqtime = detail[<span class=\"number\">2</span>]</div><div class=\"line\">\t\tvalue = compare_time(restime,reqtime)</div><div class=\"line\">\t\tkey = line.strip().split(<span class=\"string\">\"T\"</span>,<span class=\"number\">1</span>)[<span class=\"number\">0</span>]</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> key+<span class=\"string\">'\\t'</span>+str(value)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">\tmain()</div></pre></td></tr></table></figure>\n<blockquote>\n<p>red.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python  </span></div><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-   </span></div><div class=\"line\"><span class=\"keyword\">import</span> sys  </div><div class=\"line\">  </div><div class=\"line\">current_key = <span class=\"keyword\">None</span>  </div><div class=\"line\">total_take = <span class=\"number\">0</span>  </div><div class=\"line\">key = <span class=\"keyword\">None</span></div><div class=\"line\">times = <span class=\"number\">0</span>  </div><div class=\"line\">one = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:  </div><div class=\"line\">    line = line.strip()  </div><div class=\"line\">  </div><div class=\"line\">    key, time_take = line.split(<span class=\"string\">'\\t'</span>, one)  </div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        time_take = float(time_take)  </div><div class=\"line\">    <span class=\"keyword\">except</span> ValueError:  </div><div class=\"line\">        <span class=\"comment\">#bad line pass </span></div><div class=\"line\">        <span class=\"keyword\">continue</span>  </div><div class=\"line\">    <span class=\"keyword\">if</span> current_key == key:  </div><div class=\"line\">        total_take += time_take</div><div class=\"line\">        times += one</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"comment\"># if current_key ne next_key handle this logic and  print result,then init new key line data and init times</span></div><div class=\"line\">        <span class=\"keyword\">if</span> current_key:  </div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">'%s\\t%s\\t%s'</span> % (current_key,times,total_take/times)  </div><div class=\"line\">        total_take = time_take  </div><div class=\"line\">        current_key = key</div><div class=\"line\">        times = one  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># if stdin input over ,then handle this logic(there is no comparation after the last key compute ,so print here is necessary)</span></div><div class=\"line\"><span class=\"keyword\">if</span> current_key == key:</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'%s\\t%s\\t%f'</span> % (current_key,times,total_take/times)</div></pre></td></tr></table></figure>\n<h4 id=\"方法二-使用迭代器\"><a href=\"#方法二-使用迭代器\" class=\"headerlink\" title=\"方法二　使用迭代器\"></a>方法二　使用迭代器</h4><blockquote>\n<p>同样也可以利用mapreduce中间的shuffle过程，map代码同上，reduce代码则使用yield生成迭代器同时配合groupby 工具函数来完成聚合。<br>reduce.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python  </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> groupby  </div><div class=\"line\"><span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> itemgetter  </div><div class=\"line\"><span class=\"keyword\">import</span> sys  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_mapper_output</span><span class=\"params\">(file, separator=<span class=\"string\">'\\t'</span>)</span>:</span>  </div><div class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> file:  </div><div class=\"line\">        <span class=\"keyword\">yield</span> line.rstrip().split(separator, <span class=\"number\">1</span>)  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">(separator=<span class=\"string\">'\\t'</span>)</span>:</span>  </div><div class=\"line\">    data = read_mapper_output(sys.stdin, separator=separator)  </div><div class=\"line\">    <span class=\"keyword\">for</span> current_word, group <span class=\"keyword\">in</span> groupby(data, itemgetter(<span class=\"number\">0</span>)):  </div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"comment\"># (float(count) for current_word,count in group)'s return is generator,if you want handle this twice,</span></div><div class=\"line\">            <span class=\"comment\"># you should store　generator into one collection(here:list) ,if not the generator just can be used once,</span></div><div class=\"line\">            <span class=\"comment\"># because the generator.next()(once used) had pointed to the end,can’t　be used more.</span></div><div class=\"line\">            res_temp = list(float(count) <span class=\"keyword\">for</span> current_word,count <span class=\"keyword\">in</span> group)</div><div class=\"line\">            size_count = sum(<span class=\"number\">1</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> res_temp)</div><div class=\"line\">            total_count = sum(res_temp)</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"%s%s%d%s%f\"</span> % (current_word, separator, size_count ,separator ,total_count/size_count)</div><div class=\"line\">        <span class=\"keyword\">except</span> ValueError:  </div><div class=\"line\">            <span class=\"keyword\">pass</span>  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:  </div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<blockquote>\n<p>以上两种mapreduce实现逻辑，我以用蹩脚的英文解释，看不懂，就使劲儿看。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p>mapreduce思想可以很自然的解决此类问题，但是也考虑到仅有map的情况下，怎么解决？但是这次写的代码还是存在问题，后续会解决更新。</p>\n</blockquote>\n"},{"title":"python 操作mongo实现查询和聚合","date":"2017-10-12T01:38:58.000Z","_content":"\n## 需求背景:\n>分月分接口统计下我部门所有接口服务每月总计收到的请求数量\n\n## 需求分析\n>从需求字面可以理解到分析的维度是**月份**和**接口**，然后再使用**聚合**就应该可以搞定。\n\n## 技术选型\n>&ensp;&ensp;&ensp;&ensp;本来觉着使用mongo自带的聚合就可以搞定，但是月份维度的使用则很让我为难，因为时间存储的是**UTC**格式的时间(eg:ISODate(\"2016-10-18T17:22:04.563Z\")),但是分析维度用的只是具体到月份，所以直接使用不是很方便（其实是我没有找到解决方案，但个人理解是这样的两个维度去统计性能也会不理想），所以就考虑到使用容易实现的python来构建json格式的聚合实现，日期则使用遍历和角标结合的解决方案。具体代码如下:\n\n>测试代码test.py(测试服务器以及库和集合的连通性,实现查询数据的功能)\n``` python\n# -*-coding:utf-8-*-  \n#!/usr/bin/env python  \nfrom pymongo import MongoClient\n\n\ndb = MongoClient('mongodb://127.0.0.1:27017/').tal\n\ndb_data = db.sysRequestWrapper.find().limit(2)\n\nfor data in db_data:\n\tprint data\n```\n>聚合代码 mongoAggr.py\n\n``` python\n# -*-coding:utf-8-*-  \n#!/usr/bin/env python  \nimport json\nimport datetime\nfrom pymongo import MongoClient\nimport time\n\ndb = MongoClient('mongodb://127.0.0.1:27017/').tal\n\n\nstarts=['2017-01-01T','2017-02-01T','2017-03-01T','2017-04-01T','2017-05-01T','2017-06-01T','2017-07-01T','2017-08-01T','2017-09-01T','2017-10-01T']\nfor index,day in enumerate(starts):\n\tif(index == len(starts)-1):\n\t\tbreak\n\telse:\n\t\tstart = datetime.datetime.strptime(day,'%Y-%m-%dT')\n\t\tend = datetime.datetime.strptime(starts[index+1],'%Y-%m-%dT')\n\t\tpipeline = [\n\t\t     {\"$match\":{\"requestTime\":{\"$gte\":start,\"$lt\":end}}},\n\t\t     {\"$group\":{\"_id\":{\"uri\":\"$uri\"},\"count\":{\"$sum\":1}}}\n\t\t ]\n\t\tres =  list(db.sysRequestWrapper.aggregate(pipeline))\n\t\tfor item in res:\n\t\t\tretVal = eval(json.dumps(item, sort_keys=True))\n\t\t\turi = retVal['_id']['uri']\n\t\t\tcount = retVal['count']\n\t\t\tprint '%s\\t%s\\t%d' % (day[:7],uri,count)\n\n```\n## 总结:\n### 难点一:\n>&ensp;&ensp;&ensp;&ensp;纠结的时间问题，本来使用的是常规的时间，但是python不像java一样提供的是系统时间，这样导致和服务器的utc时间差八个小时，后来使用了UTC时间来规避这个问题，从而解决了查询不到的问题。\n\n### 难点二\n>多个时间区间的问题，本来考虑的是两个for循环搞定，但是灵机一动，考虑到的角标加一的解决方案。\n\n### 注意点:\n>结果的格式化、排序，以及str到ditc的转化。\n\n## 笔记\n>&ensp;&ensp;&ensp;&ensp;mongo中的date类型以UTC（Coordinated Universal Time）存储，就等于GMT（格林尼治标准时）时间。所以,java读写mongo的Date时，会根据当前系统的时区与GMT进行相互转化。我猜上述转化应该是由java的mongo驱动实现的。比如，在java中，时间2017-09-27 17:57:46.055存入mongo会转化为ISODate(\"2017-09-27T09:57:46.055Z\")，时间少了8小时，这个是由GMT+0800向GMT转化导致的。\n\n>&ensp;&ensp;&ensp;&ensp;而在python中，通常调用datetime.now()或datetime.today()返回当前时间，但是这两个方法只是返回系统时间，不返回时区。而且在python中查询mongo日期类型时，不会进行时区的转化，这就导致查询结果不准（时间大了8小时）。而解决这个问题的方法就是直接以utc格式的时间查询mongo，可以通过datetime.utcnow()返回utc时间，这个方法会根据系统当前时区把时间转化为utc格式，这样就可以查到正确的结果了。","source":"_posts/python-操作mongo实现查询和聚合.md","raw":"---\ntitle: python 操作mongo实现查询和聚合\ndate: 2017-10-12 09:38:58\ntags: python mongo\n---\n\n## 需求背景:\n>分月分接口统计下我部门所有接口服务每月总计收到的请求数量\n\n## 需求分析\n>从需求字面可以理解到分析的维度是**月份**和**接口**，然后再使用**聚合**就应该可以搞定。\n\n## 技术选型\n>&ensp;&ensp;&ensp;&ensp;本来觉着使用mongo自带的聚合就可以搞定，但是月份维度的使用则很让我为难，因为时间存储的是**UTC**格式的时间(eg:ISODate(\"2016-10-18T17:22:04.563Z\")),但是分析维度用的只是具体到月份，所以直接使用不是很方便（其实是我没有找到解决方案，但个人理解是这样的两个维度去统计性能也会不理想），所以就考虑到使用容易实现的python来构建json格式的聚合实现，日期则使用遍历和角标结合的解决方案。具体代码如下:\n\n>测试代码test.py(测试服务器以及库和集合的连通性,实现查询数据的功能)\n``` python\n# -*-coding:utf-8-*-  \n#!/usr/bin/env python  \nfrom pymongo import MongoClient\n\n\ndb = MongoClient('mongodb://127.0.0.1:27017/').tal\n\ndb_data = db.sysRequestWrapper.find().limit(2)\n\nfor data in db_data:\n\tprint data\n```\n>聚合代码 mongoAggr.py\n\n``` python\n# -*-coding:utf-8-*-  \n#!/usr/bin/env python  \nimport json\nimport datetime\nfrom pymongo import MongoClient\nimport time\n\ndb = MongoClient('mongodb://127.0.0.1:27017/').tal\n\n\nstarts=['2017-01-01T','2017-02-01T','2017-03-01T','2017-04-01T','2017-05-01T','2017-06-01T','2017-07-01T','2017-08-01T','2017-09-01T','2017-10-01T']\nfor index,day in enumerate(starts):\n\tif(index == len(starts)-1):\n\t\tbreak\n\telse:\n\t\tstart = datetime.datetime.strptime(day,'%Y-%m-%dT')\n\t\tend = datetime.datetime.strptime(starts[index+1],'%Y-%m-%dT')\n\t\tpipeline = [\n\t\t     {\"$match\":{\"requestTime\":{\"$gte\":start,\"$lt\":end}}},\n\t\t     {\"$group\":{\"_id\":{\"uri\":\"$uri\"},\"count\":{\"$sum\":1}}}\n\t\t ]\n\t\tres =  list(db.sysRequestWrapper.aggregate(pipeline))\n\t\tfor item in res:\n\t\t\tretVal = eval(json.dumps(item, sort_keys=True))\n\t\t\turi = retVal['_id']['uri']\n\t\t\tcount = retVal['count']\n\t\t\tprint '%s\\t%s\\t%d' % (day[:7],uri,count)\n\n```\n## 总结:\n### 难点一:\n>&ensp;&ensp;&ensp;&ensp;纠结的时间问题，本来使用的是常规的时间，但是python不像java一样提供的是系统时间，这样导致和服务器的utc时间差八个小时，后来使用了UTC时间来规避这个问题，从而解决了查询不到的问题。\n\n### 难点二\n>多个时间区间的问题，本来考虑的是两个for循环搞定，但是灵机一动，考虑到的角标加一的解决方案。\n\n### 注意点:\n>结果的格式化、排序，以及str到ditc的转化。\n\n## 笔记\n>&ensp;&ensp;&ensp;&ensp;mongo中的date类型以UTC（Coordinated Universal Time）存储，就等于GMT（格林尼治标准时）时间。所以,java读写mongo的Date时，会根据当前系统的时区与GMT进行相互转化。我猜上述转化应该是由java的mongo驱动实现的。比如，在java中，时间2017-09-27 17:57:46.055存入mongo会转化为ISODate(\"2017-09-27T09:57:46.055Z\")，时间少了8小时，这个是由GMT+0800向GMT转化导致的。\n\n>&ensp;&ensp;&ensp;&ensp;而在python中，通常调用datetime.now()或datetime.today()返回当前时间，但是这两个方法只是返回系统时间，不返回时区。而且在python中查询mongo日期类型时，不会进行时区的转化，这就导致查询结果不准（时间大了8小时）。而解决这个问题的方法就是直接以utc格式的时间查询mongo，可以通过datetime.utcnow()返回utc时间，这个方法会根据系统当前时区把时间转化为utc格式，这样就可以查到正确的结果了。","slug":"python-操作mongo实现查询和聚合","published":1,"updated":"2017-10-12T06:12:38.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xinq000fy8ztmiminhs7","content":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>分月分接口统计下我部门所有接口服务每月总计收到的请求数量</p>\n</blockquote>\n<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><blockquote>\n<p>从需求字面可以理解到分析的维度是<strong>月份</strong>和<strong>接口</strong>，然后再使用<strong>聚合</strong>就应该可以搞定。</p>\n</blockquote>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><blockquote>\n<p>&ensp;&ensp;&ensp;&ensp;本来觉着使用mongo自带的聚合就可以搞定，但是月份维度的使用则很让我为难，因为时间存储的是<strong>UTC</strong>格式的时间(eg:ISODate(“2016-10-18T17:22:04.563Z”)),但是分析维度用的只是具体到月份，所以直接使用不是很方便（其实是我没有找到解决方案，但个人理解是这样的两个维度去统计性能也会不理想），所以就考虑到使用容易实现的python来构建json格式的聚合实现，日期则使用遍历和角标结合的解决方案。具体代码如下:</p>\n<p>测试代码test.py(测试服务器以及库和集合的连通性,实现查询数据的功能)<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python  </span></div><div class=\"line\"><span class=\"keyword\">from</span> pymongo <span class=\"keyword\">import</span> MongoClient</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">db = MongoClient(<span class=\"string\">'mongodb://127.0.0.1:27017/'</span>).tal</div><div class=\"line\"></div><div class=\"line\">db_data = db.sysRequestWrapper.find().limit(<span class=\"number\">2</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> db_data:</div><div class=\"line\">\t<span class=\"keyword\">print</span> data</div></pre></td></tr></table></figure></p>\n<p>聚合代码 mongoAggr.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python  </span></div><div class=\"line\"><span class=\"keyword\">import</span> json</div><div class=\"line\"><span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"keyword\">from</span> pymongo <span class=\"keyword\">import</span> MongoClient</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\">db = MongoClient(<span class=\"string\">'mongodb://127.0.0.1:27017/'</span>).tal</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">starts=[<span class=\"string\">'2017-01-01T'</span>,<span class=\"string\">'2017-02-01T'</span>,<span class=\"string\">'2017-03-01T'</span>,<span class=\"string\">'2017-04-01T'</span>,<span class=\"string\">'2017-05-01T'</span>,<span class=\"string\">'2017-06-01T'</span>,<span class=\"string\">'2017-07-01T'</span>,<span class=\"string\">'2017-08-01T'</span>,<span class=\"string\">'2017-09-01T'</span>,<span class=\"string\">'2017-10-01T'</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> index,day <span class=\"keyword\">in</span> enumerate(starts):</div><div class=\"line\">\t<span class=\"keyword\">if</span>(index == len(starts)<span class=\"number\">-1</span>):</div><div class=\"line\">\t\t<span class=\"keyword\">break</span></div><div class=\"line\">\t<span class=\"keyword\">else</span>:</div><div class=\"line\">\t\tstart = datetime.datetime.strptime(day,<span class=\"string\">'%Y-%m-%dT'</span>)</div><div class=\"line\">\t\tend = datetime.datetime.strptime(starts[index+<span class=\"number\">1</span>],<span class=\"string\">'%Y-%m-%dT'</span>)</div><div class=\"line\">\t\tpipeline = [</div><div class=\"line\">\t\t     &#123;<span class=\"string\">\"$match\"</span>:&#123;<span class=\"string\">\"requestTime\"</span>:&#123;<span class=\"string\">\"$gte\"</span>:start,<span class=\"string\">\"$lt\"</span>:end&#125;&#125;&#125;,</div><div class=\"line\">\t\t     &#123;<span class=\"string\">\"$group\"</span>:&#123;<span class=\"string\">\"_id\"</span>:&#123;<span class=\"string\">\"uri\"</span>:<span class=\"string\">\"$uri\"</span>&#125;,<span class=\"string\">\"count\"</span>:&#123;<span class=\"string\">\"$sum\"</span>:<span class=\"number\">1</span>&#125;&#125;&#125;</div><div class=\"line\">\t\t ]</div><div class=\"line\">\t\tres =  list(db.sysRequestWrapper.aggregate(pipeline))</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> res:</div><div class=\"line\">\t\t\tretVal = eval(json.dumps(item, sort_keys=<span class=\"keyword\">True</span>))</div><div class=\"line\">\t\t\turi = retVal[<span class=\"string\">'_id'</span>][<span class=\"string\">'uri'</span>]</div><div class=\"line\">\t\t\tcount = retVal[<span class=\"string\">'count'</span>]</div><div class=\"line\">\t\t\t<span class=\"keyword\">print</span> <span class=\"string\">'%s\\t%s\\t%d'</span> % (day[:<span class=\"number\">7</span>],uri,count)</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h2><h3 id=\"难点一\"><a href=\"#难点一\" class=\"headerlink\" title=\"难点一:\"></a>难点一:</h3><blockquote>\n<p>&ensp;&ensp;&ensp;&ensp;纠结的时间问题，本来使用的是常规的时间，但是python不像java一样提供的是系统时间，这样导致和服务器的utc时间差八个小时，后来使用了UTC时间来规避这个问题，从而解决了查询不到的问题。</p>\n</blockquote>\n<h3 id=\"难点二\"><a href=\"#难点二\" class=\"headerlink\" title=\"难点二\"></a>难点二</h3><blockquote>\n<p>多个时间区间的问题，本来考虑的是两个for循环搞定，但是灵机一动，考虑到的角标加一的解决方案。</p>\n</blockquote>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点:\"></a>注意点:</h3><blockquote>\n<p>结果的格式化、排序，以及str到ditc的转化。</p>\n</blockquote>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><blockquote>\n<p>&ensp;&ensp;&ensp;&ensp;mongo中的date类型以UTC（Coordinated Universal Time）存储，就等于GMT（格林尼治标准时）时间。所以,java读写mongo的Date时，会根据当前系统的时区与GMT进行相互转化。我猜上述转化应该是由java的mongo驱动实现的。比如，在java中，时间2017-09-27 17:57:46.055存入mongo会转化为ISODate(“2017-09-27T09:57:46.055Z”)，时间少了8小时，这个是由GMT+0800向GMT转化导致的。</p>\n<p>&ensp;&ensp;&ensp;&ensp;而在python中，通常调用datetime.now()或datetime.today()返回当前时间，但是这两个方法只是返回系统时间，不返回时区。而且在python中查询mongo日期类型时，不会进行时区的转化，这就导致查询结果不准（时间大了8小时）。而解决这个问题的方法就是直接以utc格式的时间查询mongo，可以通过datetime.utcnow()返回utc时间，这个方法会根据系统当前时区把时间转化为utc格式，这样就可以查到正确的结果了。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>分月分接口统计下我部门所有接口服务每月总计收到的请求数量</p>\n</blockquote>\n<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><blockquote>\n<p>从需求字面可以理解到分析的维度是<strong>月份</strong>和<strong>接口</strong>，然后再使用<strong>聚合</strong>就应该可以搞定。</p>\n</blockquote>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><blockquote>\n<p>&ensp;&ensp;&ensp;&ensp;本来觉着使用mongo自带的聚合就可以搞定，但是月份维度的使用则很让我为难，因为时间存储的是<strong>UTC</strong>格式的时间(eg:ISODate(“2016-10-18T17:22:04.563Z”)),但是分析维度用的只是具体到月份，所以直接使用不是很方便（其实是我没有找到解决方案，但个人理解是这样的两个维度去统计性能也会不理想），所以就考虑到使用容易实现的python来构建json格式的聚合实现，日期则使用遍历和角标结合的解决方案。具体代码如下:</p>\n<p>测试代码test.py(测试服务器以及库和集合的连通性,实现查询数据的功能)<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python  </span></div><div class=\"line\"><span class=\"keyword\">from</span> pymongo <span class=\"keyword\">import</span> MongoClient</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">db = MongoClient(<span class=\"string\">'mongodb://127.0.0.1:27017/'</span>).tal</div><div class=\"line\"></div><div class=\"line\">db_data = db.sysRequestWrapper.find().limit(<span class=\"number\">2</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> db_data:</div><div class=\"line\">\t<span class=\"keyword\">print</span> data</div></pre></td></tr></table></figure></p>\n<p>聚合代码 mongoAggr.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*-coding:utf-8-*-  </span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python  </span></div><div class=\"line\"><span class=\"keyword\">import</span> json</div><div class=\"line\"><span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"keyword\">from</span> pymongo <span class=\"keyword\">import</span> MongoClient</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\">db = MongoClient(<span class=\"string\">'mongodb://127.0.0.1:27017/'</span>).tal</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">starts=[<span class=\"string\">'2017-01-01T'</span>,<span class=\"string\">'2017-02-01T'</span>,<span class=\"string\">'2017-03-01T'</span>,<span class=\"string\">'2017-04-01T'</span>,<span class=\"string\">'2017-05-01T'</span>,<span class=\"string\">'2017-06-01T'</span>,<span class=\"string\">'2017-07-01T'</span>,<span class=\"string\">'2017-08-01T'</span>,<span class=\"string\">'2017-09-01T'</span>,<span class=\"string\">'2017-10-01T'</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> index,day <span class=\"keyword\">in</span> enumerate(starts):</div><div class=\"line\">\t<span class=\"keyword\">if</span>(index == len(starts)<span class=\"number\">-1</span>):</div><div class=\"line\">\t\t<span class=\"keyword\">break</span></div><div class=\"line\">\t<span class=\"keyword\">else</span>:</div><div class=\"line\">\t\tstart = datetime.datetime.strptime(day,<span class=\"string\">'%Y-%m-%dT'</span>)</div><div class=\"line\">\t\tend = datetime.datetime.strptime(starts[index+<span class=\"number\">1</span>],<span class=\"string\">'%Y-%m-%dT'</span>)</div><div class=\"line\">\t\tpipeline = [</div><div class=\"line\">\t\t     &#123;<span class=\"string\">\"$match\"</span>:&#123;<span class=\"string\">\"requestTime\"</span>:&#123;<span class=\"string\">\"$gte\"</span>:start,<span class=\"string\">\"$lt\"</span>:end&#125;&#125;&#125;,</div><div class=\"line\">\t\t     &#123;<span class=\"string\">\"$group\"</span>:&#123;<span class=\"string\">\"_id\"</span>:&#123;<span class=\"string\">\"uri\"</span>:<span class=\"string\">\"$uri\"</span>&#125;,<span class=\"string\">\"count\"</span>:&#123;<span class=\"string\">\"$sum\"</span>:<span class=\"number\">1</span>&#125;&#125;&#125;</div><div class=\"line\">\t\t ]</div><div class=\"line\">\t\tres =  list(db.sysRequestWrapper.aggregate(pipeline))</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> res:</div><div class=\"line\">\t\t\tretVal = eval(json.dumps(item, sort_keys=<span class=\"keyword\">True</span>))</div><div class=\"line\">\t\t\turi = retVal[<span class=\"string\">'_id'</span>][<span class=\"string\">'uri'</span>]</div><div class=\"line\">\t\t\tcount = retVal[<span class=\"string\">'count'</span>]</div><div class=\"line\">\t\t\t<span class=\"keyword\">print</span> <span class=\"string\">'%s\\t%s\\t%d'</span> % (day[:<span class=\"number\">7</span>],uri,count)</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h2><h3 id=\"难点一\"><a href=\"#难点一\" class=\"headerlink\" title=\"难点一:\"></a>难点一:</h3><blockquote>\n<p>&ensp;&ensp;&ensp;&ensp;纠结的时间问题，本来使用的是常规的时间，但是python不像java一样提供的是系统时间，这样导致和服务器的utc时间差八个小时，后来使用了UTC时间来规避这个问题，从而解决了查询不到的问题。</p>\n</blockquote>\n<h3 id=\"难点二\"><a href=\"#难点二\" class=\"headerlink\" title=\"难点二\"></a>难点二</h3><blockquote>\n<p>多个时间区间的问题，本来考虑的是两个for循环搞定，但是灵机一动，考虑到的角标加一的解决方案。</p>\n</blockquote>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点:\"></a>注意点:</h3><blockquote>\n<p>结果的格式化、排序，以及str到ditc的转化。</p>\n</blockquote>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><blockquote>\n<p>&ensp;&ensp;&ensp;&ensp;mongo中的date类型以UTC（Coordinated Universal Time）存储，就等于GMT（格林尼治标准时）时间。所以,java读写mongo的Date时，会根据当前系统的时区与GMT进行相互转化。我猜上述转化应该是由java的mongo驱动实现的。比如，在java中，时间2017-09-27 17:57:46.055存入mongo会转化为ISODate(“2017-09-27T09:57:46.055Z”)，时间少了8小时，这个是由GMT+0800向GMT转化导致的。</p>\n<p>&ensp;&ensp;&ensp;&ensp;而在python中，通常调用datetime.now()或datetime.today()返回当前时间，但是这两个方法只是返回系统时间，不返回时区。而且在python中查询mongo日期类型时，不会进行时区的转化，这就导致查询结果不准（时间大了8小时）。而解决这个问题的方法就是直接以utc格式的时间查询mongo，可以通过datetime.utcnow()返回utc时间，这个方法会根据系统当前时区把时间转化为utc格式，这样就可以查到正确的结果了。</p>\n</blockquote>\n"},{"title":"shell在指定行插入文本","date":"2017-09-18T12:28:34.000Z","_content":"# 需求背景\n>在指定行插入特定文本\n\n## 用法\n\n``` bash\n$ sed -i '第几行i文本内容' 文件\n```\n\nps:sed -i 会直接改变文件的内容\n\n## 特殊用法\n>在a文件的第三行插入只有一个空格的空行\n\n``` bash\nsed -i '3i\\ ' a\n```\n","source":"_posts/shell在指定行插入文本.md","raw":"---\ntitle: shell在指定行插入文本\ndate: 2017-09-18 20:28:34\ntags: shell sed\n---\n# 需求背景\n>在指定行插入特定文本\n\n## 用法\n\n``` bash\n$ sed -i '第几行i文本内容' 文件\n```\n\nps:sed -i 会直接改变文件的内容\n\n## 特殊用法\n>在a文件的第三行插入只有一个空格的空行\n\n``` bash\nsed -i '3i\\ ' a\n```\n","slug":"shell在指定行插入文本","published":1,"updated":"2017-09-21T08:18:29.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xinr000hy8ztfy230im2","content":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h1><blockquote>\n<p>在指定行插入特定文本</p>\n</blockquote>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sed -i <span class=\"string\">'第几行i文本内容'</span> 文件</div></pre></td></tr></table></figure>\n<p>ps:sed -i 会直接改变文件的内容</p>\n<h2 id=\"特殊用法\"><a href=\"#特殊用法\" class=\"headerlink\" title=\"特殊用法\"></a>特殊用法</h2><blockquote>\n<p>在a文件的第三行插入只有一个空格的空行</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -i <span class=\"string\">'3i\\ '</span> a</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h1><blockquote>\n<p>在指定行插入特定文本</p>\n</blockquote>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sed -i <span class=\"string\">'第几行i文本内容'</span> 文件</div></pre></td></tr></table></figure>\n<p>ps:sed -i 会直接改变文件的内容</p>\n<h2 id=\"特殊用法\"><a href=\"#特殊用法\" class=\"headerlink\" title=\"特殊用法\"></a>特殊用法</h2><blockquote>\n<p>在a文件的第三行插入只有一个空格的空行</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -i <span class=\"string\">'3i\\ '</span> a</div></pre></td></tr></table></figure>\n"},{"title":"spark lzo 体验","date":"2017-09-21T09:07:52.000Z","_content":"\n## 需求背景：\n\n>项目中需要读取lzo文件并且提取其中的几个字段放到表中，与另一个文件join，建立映射文件，并存储为parquet格式。\n\n## 技术实现\n\n>具体实现如下：\n\n``` scala\nvar midPidCard = sc.newAPIHadoopFile[LongWritable, Text, LzoTextInputFormat](args(1)).map(_._2.toString.split(\",\")).map(mpc => MidPidCard(mpc(1), mpc(16), mpc(0), mpc(3), mpc(18))).toDF()\n```\n\n## 注意点：\n\n>一、使用hadoopapi指定输入文件格式为lzoText\n\n>二、需要注意的是该方法返回的是tuple格式的rdd。\n\n>tuple中有两个元素，\n\n>其一是文件中的行数据偏移量，\n\n>其二是当前行的内容，我们需要关心的是行内容，所以需要指定处理的内容为_._2。","source":"_posts/spark-lzo-体验.md","raw":"---\ntitle: spark lzo 体验\ndate: 2017-09-21 17:07:52\ntags: spark lzo \n---\n\n## 需求背景：\n\n>项目中需要读取lzo文件并且提取其中的几个字段放到表中，与另一个文件join，建立映射文件，并存储为parquet格式。\n\n## 技术实现\n\n>具体实现如下：\n\n``` scala\nvar midPidCard = sc.newAPIHadoopFile[LongWritable, Text, LzoTextInputFormat](args(1)).map(_._2.toString.split(\",\")).map(mpc => MidPidCard(mpc(1), mpc(16), mpc(0), mpc(3), mpc(18))).toDF()\n```\n\n## 注意点：\n\n>一、使用hadoopapi指定输入文件格式为lzoText\n\n>二、需要注意的是该方法返回的是tuple格式的rdd。\n\n>tuple中有两个元素，\n\n>其一是文件中的行数据偏移量，\n\n>其二是当前行的内容，我们需要关心的是行内容，所以需要指定处理的内容为_._2。","slug":"spark-lzo-体验","published":1,"updated":"2017-09-21T09:28:17.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xins000jy8ztnzd4s3dq","content":"<h2 id=\"需求背景：\"><a href=\"#需求背景：\" class=\"headerlink\" title=\"需求背景：\"></a>需求背景：</h2><blockquote>\n<p>项目中需要读取lzo文件并且提取其中的几个字段放到表中，与另一个文件join，建立映射文件，并存储为parquet格式。</p>\n</blockquote>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><blockquote>\n<p>具体实现如下：</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> midPidCard = sc.newAPIHadoopFile[<span class=\"type\">LongWritable</span>, <span class=\"type\">Text</span>, <span class=\"type\">LzoTextInputFormat</span>](args(<span class=\"number\">1</span>)).map(_._2.toString.split(<span class=\"string\">\",\"</span>)).map(mpc =&gt; <span class=\"type\">MidPidCard</span>(mpc(<span class=\"number\">1</span>), mpc(<span class=\"number\">16</span>), mpc(<span class=\"number\">0</span>), mpc(<span class=\"number\">3</span>), mpc(<span class=\"number\">18</span>))).toDF()</div></pre></td></tr></table></figure>\n<h2 id=\"注意点：\"><a href=\"#注意点：\" class=\"headerlink\" title=\"注意点：\"></a>注意点：</h2><blockquote>\n<p>一、使用hadoopapi指定输入文件格式为lzoText</p>\n<p>二、需要注意的是该方法返回的是tuple格式的rdd。</p>\n<p>tuple中有两个元素，</p>\n<p>其一是文件中的行数据偏移量，</p>\n<p>其二是当前行的内容，我们需要关心的是行内容，所以需要指定处理的内容为_._2。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景：\"><a href=\"#需求背景：\" class=\"headerlink\" title=\"需求背景：\"></a>需求背景：</h2><blockquote>\n<p>项目中需要读取lzo文件并且提取其中的几个字段放到表中，与另一个文件join，建立映射文件，并存储为parquet格式。</p>\n</blockquote>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><blockquote>\n<p>具体实现如下：</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> midPidCard = sc.newAPIHadoopFile[<span class=\"type\">LongWritable</span>, <span class=\"type\">Text</span>, <span class=\"type\">LzoTextInputFormat</span>](args(<span class=\"number\">1</span>)).map(_._2.toString.split(<span class=\"string\">\",\"</span>)).map(mpc =&gt; <span class=\"type\">MidPidCard</span>(mpc(<span class=\"number\">1</span>), mpc(<span class=\"number\">16</span>), mpc(<span class=\"number\">0</span>), mpc(<span class=\"number\">3</span>), mpc(<span class=\"number\">18</span>))).toDF()</div></pre></td></tr></table></figure>\n<h2 id=\"注意点：\"><a href=\"#注意点：\" class=\"headerlink\" title=\"注意点：\"></a>注意点：</h2><blockquote>\n<p>一、使用hadoopapi指定输入文件格式为lzoText</p>\n<p>二、需要注意的是该方法返回的是tuple格式的rdd。</p>\n<p>tuple中有两个元素，</p>\n<p>其一是文件中的行数据偏移量，</p>\n<p>其二是当前行的内容，我们需要关心的是行内容，所以需要指定处理的内容为_._2。</p>\n</blockquote>\n"},{"title":"spark 项目启动的时候报出如下错误","date":"2017-09-19T06:01:46.000Z","_content":"## 需求背景:\n>在spark打包启动的时候报错信息如下:\n\n``` java\n“class \"javax.servlet.FilterRegistration\"'s signer information does not match signer information of other classes in the same package”\n```\n## 细节分析:\n\n>从字面意思可以看出是因为pom中有多个jar包中出现了该类，在程序中或者依赖的程序去使用该类的时候导致无法唯一确定jar包的来源.\n\n## 解决方案:\n\n>对于此类问题处理的方式是：\n找到该类所在的父gav然后在其中exesusion掉该jar包，因为exesusion只可以指定到ga,所以就会把该类所有的jar包去掉，但是如果这么用又会出现该类找不到（no class found）,此时的解决办法就是引入一个确定的jar包版本指定gav,放在exclusion父类之前.\n","source":"_posts/spark-项目启动的时候报出如下错误.md","raw":"---\ntitle: spark 项目启动的时候报出如下错误\ndate: 2017-09-19 14:01:46\ntags: spark not match\n---\n## 需求背景:\n>在spark打包启动的时候报错信息如下:\n\n``` java\n“class \"javax.servlet.FilterRegistration\"'s signer information does not match signer information of other classes in the same package”\n```\n## 细节分析:\n\n>从字面意思可以看出是因为pom中有多个jar包中出现了该类，在程序中或者依赖的程序去使用该类的时候导致无法唯一确定jar包的来源.\n\n## 解决方案:\n\n>对于此类问题处理的方式是：\n找到该类所在的父gav然后在其中exesusion掉该jar包，因为exesusion只可以指定到ga,所以就会把该类所有的jar包去掉，但是如果这么用又会出现该类找不到（no class found）,此时的解决办法就是引入一个确定的jar包版本指定gav,放在exclusion父类之前.\n","slug":"spark-项目启动的时候报出如下错误","published":1,"updated":"2017-09-25T02:18:27.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xint000ly8zt4gacwg50","content":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>在spark打包启动的时候报错信息如下:</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">“class \"javax.servlet.FilterRegistration\"'s signer information does not match signer information of other classes in the same package”</div></pre></td></tr></table></figure>\n<h2 id=\"细节分析\"><a href=\"#细节分析\" class=\"headerlink\" title=\"细节分析:\"></a>细节分析:</h2><blockquote>\n<p>从字面意思可以看出是因为pom中有多个jar包中出现了该类，在程序中或者依赖的程序去使用该类的时候导致无法唯一确定jar包的来源.</p>\n</blockquote>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><blockquote>\n<p>对于此类问题处理的方式是：<br>找到该类所在的父gav然后在其中exesusion掉该jar包，因为exesusion只可以指定到ga,所以就会把该类所有的jar包去掉，但是如果这么用又会出现该类找不到（no class found）,此时的解决办法就是引入一个确定的jar包版本指定gav,放在exclusion父类之前.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>在spark打包启动的时候报错信息如下:</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">“class \"javax.servlet.FilterRegistration\"'s signer information does not match signer information of other classes in the same package”</div></pre></td></tr></table></figure>\n<h2 id=\"细节分析\"><a href=\"#细节分析\" class=\"headerlink\" title=\"细节分析:\"></a>细节分析:</h2><blockquote>\n<p>从字面意思可以看出是因为pom中有多个jar包中出现了该类，在程序中或者依赖的程序去使用该类的时候导致无法唯一确定jar包的来源.</p>\n</blockquote>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><blockquote>\n<p>对于此类问题处理的方式是：<br>找到该类所在的父gav然后在其中exesusion掉该jar包，因为exesusion只可以指定到ga,所以就会把该类所有的jar包去掉，但是如果这么用又会出现该类找不到（no class found）,此时的解决办法就是引入一个确定的jar包版本指定gav,放在exclusion父类之前.</p>\n</blockquote>\n"},{"title":"spark scala中map和flatmap的区别","date":"2017-09-19T09:20:15.000Z","_content":"# 需求背景：\n\n> 统计相邻两个单词出现的次数。\n\n## 技术实现\n\n``` scala\nval s=\"A;B;C;D;B;D;C;B;D;A;E;D;C;A;B\"\n\ns: String = A;B;C;D;B;D;C;B;D;A;E;D;C;A;B\n\n val data=sc.parallelize(Seq(s))\n\ndata.collect()\n\nres0: Array[String] = Array(A;B;C;D;B;D;C;B;D;A;E;D;C;A;B)       \n```\n> 截止目前位置是一个String类型的数组。\n\n``` scala\nval mapTemp=data.map(_.split(\";\"))\n\nscala> mapTemp.collect\n\nres4: Array[Array[String]] = Array(Array(A, B, C, D, B, D, C, B, D, A, E, D, C, A, B))\n```\n> map操作在于处理之前和处理之后的数据类型是一致的。\n\n``` scala\nval mapRs=data.map(_.split(\";\")).map(x=>{for(i<-0 until x.length-1) yield (x(i)+\",\"+x(i+1),1)})\n\nmapRs.collect\n\nres1: Array[scala.collection.immutable.IndexedSeq[(String, Int)]] = Array(Vector((A,B,1), (B,C,1), (C,D,1), (D,B,1), (B,D,1), (D,C,1), (C,B,1), (B,D,1), (D,A,1), (A,E,1), (E,D,1), (D,C,1), (C,A,1), (A,B,1)))\n```\n> *map输出的数据类型:Array[scala.collection.immutable.IndexedSeq[(String, Int)]]*\n> 而flatMap会把一类集合类的数据抹平从而展示的效果是元素的方式，真实效果:从Vector中遍历然后罗列出来。\n\n``` scala\nval flatMapRs=data.map(_.split(\";\")).flatMap(x=>{for(i<-0 until x.length-1) yield　(x(i)+\",\"+x(i+1),1)})\n\nflatMapRs.collect\n\nres3: Array[(String, Int)] = Array((A,B,1), (B,C,1), (C,D,1), (D,B,1), (B,D,1), (D,C,1), (C,B,1), (B,D,1), (D,A,1), (A,E,1), (E,D,1), (D,C,1), (C,A,1), (A,B,1))\n```\n> flatmap输出的数据类型:Array[(String, Int)]*\n\n## 最终结果\n\n``` scala\nval flatMap= data.map(_.split(\";\")).flatMap(x=>{for(i<-0 until x.length-1) yield (x(i)+\",\"+x(i+1),1)}).reduceByKey(_+_).foreach(println)\n```\n(A,E,1)\n\n(C,D,1)\n\n(B,D,2)\n\n(D,B,1)\n\n(C,A,1)\n\n(C,B,1)\n\n(E,D,1)\n\n(D,A,1)\n\n(B,C,1)\n\n(D,C,2)\n\n(A,B,2)\n## 总结一下:\n> 处理以前一定要意识到你自己最终拿到的数据的格式,如果是集合类的你则最终需要需要flat(抹平操作),从而才能使用一些函数对每个元素进行处理.\n\n\n## reduceByKey算数因子解释：\n\n> Basically reduceByKey function works only for RDDs which contains key and value pairs kind of   elements(i.e RDDs having tuple or Map as a data element). It is a transformation operation   which means it is lazily evaluated.We need to pass one associative function as a parameter,   which will be applied to the source RDD and will create anew RDD as with resulting values(i.e.  key value pair). This operation is a wide operation as data shuffling may happen across the   partitions.【本质上来讲，reduceByKey函数（说算子也可以）只作用于包含key-value的RDDS上，它是  transformation类型的算子，这也就意味着它是懒加载的（就是说不调用Action的方法，是不会去计算的  ）,在使用时，我们需要传递一个相关的函数（_+_）作为参数，这个函数将会被应用到源RDD上并且创建一个新的  RDD作为返回结果，这个算子作为data Shuffling 在分区的时候被广泛使用】  \n","source":"_posts/spark-scala中map和flatmap的区别.md","raw":"---\ntitle: spark scala中map和flatmap的区别\ndate: 2017-09-19 17:20:15\ntags: spark scala map flatmap \n---\n# 需求背景：\n\n> 统计相邻两个单词出现的次数。\n\n## 技术实现\n\n``` scala\nval s=\"A;B;C;D;B;D;C;B;D;A;E;D;C;A;B\"\n\ns: String = A;B;C;D;B;D;C;B;D;A;E;D;C;A;B\n\n val data=sc.parallelize(Seq(s))\n\ndata.collect()\n\nres0: Array[String] = Array(A;B;C;D;B;D;C;B;D;A;E;D;C;A;B)       \n```\n> 截止目前位置是一个String类型的数组。\n\n``` scala\nval mapTemp=data.map(_.split(\";\"))\n\nscala> mapTemp.collect\n\nres4: Array[Array[String]] = Array(Array(A, B, C, D, B, D, C, B, D, A, E, D, C, A, B))\n```\n> map操作在于处理之前和处理之后的数据类型是一致的。\n\n``` scala\nval mapRs=data.map(_.split(\";\")).map(x=>{for(i<-0 until x.length-1) yield (x(i)+\",\"+x(i+1),1)})\n\nmapRs.collect\n\nres1: Array[scala.collection.immutable.IndexedSeq[(String, Int)]] = Array(Vector((A,B,1), (B,C,1), (C,D,1), (D,B,1), (B,D,1), (D,C,1), (C,B,1), (B,D,1), (D,A,1), (A,E,1), (E,D,1), (D,C,1), (C,A,1), (A,B,1)))\n```\n> *map输出的数据类型:Array[scala.collection.immutable.IndexedSeq[(String, Int)]]*\n> 而flatMap会把一类集合类的数据抹平从而展示的效果是元素的方式，真实效果:从Vector中遍历然后罗列出来。\n\n``` scala\nval flatMapRs=data.map(_.split(\";\")).flatMap(x=>{for(i<-0 until x.length-1) yield　(x(i)+\",\"+x(i+1),1)})\n\nflatMapRs.collect\n\nres3: Array[(String, Int)] = Array((A,B,1), (B,C,1), (C,D,1), (D,B,1), (B,D,1), (D,C,1), (C,B,1), (B,D,1), (D,A,1), (A,E,1), (E,D,1), (D,C,1), (C,A,1), (A,B,1))\n```\n> flatmap输出的数据类型:Array[(String, Int)]*\n\n## 最终结果\n\n``` scala\nval flatMap= data.map(_.split(\";\")).flatMap(x=>{for(i<-0 until x.length-1) yield (x(i)+\",\"+x(i+1),1)}).reduceByKey(_+_).foreach(println)\n```\n(A,E,1)\n\n(C,D,1)\n\n(B,D,2)\n\n(D,B,1)\n\n(C,A,1)\n\n(C,B,1)\n\n(E,D,1)\n\n(D,A,1)\n\n(B,C,1)\n\n(D,C,2)\n\n(A,B,2)\n## 总结一下:\n> 处理以前一定要意识到你自己最终拿到的数据的格式,如果是集合类的你则最终需要需要flat(抹平操作),从而才能使用一些函数对每个元素进行处理.\n\n\n## reduceByKey算数因子解释：\n\n> Basically reduceByKey function works only for RDDs which contains key and value pairs kind of   elements(i.e RDDs having tuple or Map as a data element). It is a transformation operation   which means it is lazily evaluated.We need to pass one associative function as a parameter,   which will be applied to the source RDD and will create anew RDD as with resulting values(i.e.  key value pair). This operation is a wide operation as data shuffling may happen across the   partitions.【本质上来讲，reduceByKey函数（说算子也可以）只作用于包含key-value的RDDS上，它是  transformation类型的算子，这也就意味着它是懒加载的（就是说不调用Action的方法，是不会去计算的  ）,在使用时，我们需要传递一个相关的函数（_+_）作为参数，这个函数将会被应用到源RDD上并且创建一个新的  RDD作为返回结果，这个算子作为data Shuffling 在分区的时候被广泛使用】  \n","slug":"spark-scala中map和flatmap的区别","published":1,"updated":"2017-09-19T09:54:21.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xinu000my8zt5wfhdvkh","content":"<h1 id=\"需求背景：\"><a href=\"#需求背景：\" class=\"headerlink\" title=\"需求背景：\"></a>需求背景：</h1><blockquote>\n<p>统计相邻两个单词出现的次数。</p>\n</blockquote>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">val</span> s=<span class=\"string\">\"A;B;C;D;B;D;C;B;D;A;E;D;C;A;B\"</span></div><div class=\"line\"></div><div class=\"line\">s: <span class=\"type\">String</span> = <span class=\"type\">A</span>;<span class=\"type\">B</span>;<span class=\"type\">C</span>;<span class=\"type\">D</span>;<span class=\"type\">B</span>;<span class=\"type\">D</span>;<span class=\"type\">C</span>;<span class=\"type\">B</span>;<span class=\"type\">D</span>;<span class=\"type\">A</span>;<span class=\"type\">E</span>;<span class=\"type\">D</span>;<span class=\"type\">C</span>;<span class=\"type\">A</span>;<span class=\"type\">B</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">val</span> data=sc.parallelize(<span class=\"type\">Seq</span>(s))</div><div class=\"line\"></div><div class=\"line\">data.collect()</div><div class=\"line\"></div><div class=\"line\">res0: <span class=\"type\">Array</span>[<span class=\"type\">String</span>] = <span class=\"type\">Array</span>(<span class=\"type\">A</span>;<span class=\"type\">B</span>;<span class=\"type\">C</span>;<span class=\"type\">D</span>;<span class=\"type\">B</span>;<span class=\"type\">D</span>;<span class=\"type\">C</span>;<span class=\"type\">B</span>;<span class=\"type\">D</span>;<span class=\"type\">A</span>;<span class=\"type\">E</span>;<span class=\"type\">D</span>;<span class=\"type\">C</span>;<span class=\"type\">A</span>;<span class=\"type\">B</span>)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>截止目前位置是一个String类型的数组。</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">val</span> mapTemp=data.map(_.split(<span class=\"string\">\";\"</span>))</div><div class=\"line\"></div><div class=\"line\">scala&gt; mapTemp.collect</div><div class=\"line\"></div><div class=\"line\">res4: <span class=\"type\">Array</span>[<span class=\"type\">Array</span>[<span class=\"type\">String</span>]] = <span class=\"type\">Array</span>(<span class=\"type\">Array</span>(<span class=\"type\">A</span>, <span class=\"type\">B</span>, <span class=\"type\">C</span>, <span class=\"type\">D</span>, <span class=\"type\">B</span>, <span class=\"type\">D</span>, <span class=\"type\">C</span>, <span class=\"type\">B</span>, <span class=\"type\">D</span>, <span class=\"type\">A</span>, <span class=\"type\">E</span>, <span class=\"type\">D</span>, <span class=\"type\">C</span>, <span class=\"type\">A</span>, <span class=\"type\">B</span>))</div></pre></td></tr></table></figure>\n<blockquote>\n<p>map操作在于处理之前和处理之后的数据类型是一致的。</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">val</span> mapRs=data.map(_.split(<span class=\"string\">\";\"</span>)).map(x=&gt;&#123;<span class=\"keyword\">for</span>(i&lt;<span class=\"number\">-0</span> until x.length<span class=\"number\">-1</span>) <span class=\"keyword\">yield</span> (x(i)+<span class=\"string\">\",\"</span>+x(i+<span class=\"number\">1</span>),<span class=\"number\">1</span>)&#125;)</div><div class=\"line\"></div><div class=\"line\">mapRs.collect</div><div class=\"line\"></div><div class=\"line\">res1: <span class=\"type\">Array</span>[scala.collection.immutable.<span class=\"type\">IndexedSeq</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)]] = <span class=\"type\">Array</span>(<span class=\"type\">Vector</span>((<span class=\"type\">A</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">A</span>,<span class=\"number\">1</span>), (<span class=\"type\">A</span>,<span class=\"type\">E</span>,<span class=\"number\">1</span>), (<span class=\"type\">E</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">A</span>,<span class=\"number\">1</span>), (<span class=\"type\">A</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>)))</div></pre></td></tr></table></figure>\n<blockquote>\n<p><em>map输出的数据类型:Array[scala.collection.immutable.IndexedSeq[(String, Int)]]</em><br>而flatMap会把一类集合类的数据抹平从而展示的效果是元素的方式，真实效果:从Vector中遍历然后罗列出来。</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">val</span> flatMapRs=data.map(_.split(<span class=\"string\">\";\"</span>)).flatMap(x=&gt;&#123;<span class=\"keyword\">for</span>(i&lt;<span class=\"number\">-0</span> until x.length<span class=\"number\">-1</span>) <span class=\"keyword\">yield</span>　(x(i)+<span class=\"string\">\",\"</span>+x(i+<span class=\"number\">1</span>),<span class=\"number\">1</span>)&#125;)</div><div class=\"line\"></div><div class=\"line\">flatMapRs.collect</div><div class=\"line\"></div><div class=\"line\">res3: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = <span class=\"type\">Array</span>((<span class=\"type\">A</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">A</span>,<span class=\"number\">1</span>), (<span class=\"type\">A</span>,<span class=\"type\">E</span>,<span class=\"number\">1</span>), (<span class=\"type\">E</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">A</span>,<span class=\"number\">1</span>), (<span class=\"type\">A</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>))</div></pre></td></tr></table></figure>\n<blockquote>\n<p>flatmap输出的数据类型:Array[(String, Int)]*</p>\n</blockquote>\n<h2 id=\"最终结果\"><a href=\"#最终结果\" class=\"headerlink\" title=\"最终结果\"></a>最终结果</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">val</span> flatMap= data.map(_.split(<span class=\"string\">\";\"</span>)).flatMap(x=&gt;&#123;<span class=\"keyword\">for</span>(i&lt;<span class=\"number\">-0</span> until x.length<span class=\"number\">-1</span>) <span class=\"keyword\">yield</span> (x(i)+<span class=\"string\">\",\"</span>+x(i+<span class=\"number\">1</span>),<span class=\"number\">1</span>)&#125;).reduceByKey(_+_).foreach(println)</div></pre></td></tr></table></figure>\n<p>(A,E,1)</p>\n<p>(C,D,1)</p>\n<p>(B,D,2)</p>\n<p>(D,B,1)</p>\n<p>(C,A,1)</p>\n<p>(C,B,1)</p>\n<p>(E,D,1)</p>\n<p>(D,A,1)</p>\n<p>(B,C,1)</p>\n<p>(D,C,2)</p>\n<p>(A,B,2)</p>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下:\"></a>总结一下:</h2><blockquote>\n<p>处理以前一定要意识到你自己最终拿到的数据的格式,如果是集合类的你则最终需要需要flat(抹平操作),从而才能使用一些函数对每个元素进行处理.</p>\n</blockquote>\n<h2 id=\"reduceByKey算数因子解释：\"><a href=\"#reduceByKey算数因子解释：\" class=\"headerlink\" title=\"reduceByKey算数因子解释：\"></a>reduceByKey算数因子解释：</h2><blockquote>\n<p>Basically reduceByKey function works only for RDDs which contains key and value pairs kind of   elements(i.e RDDs having tuple or Map as a data element). It is a transformation operation   which means it is lazily evaluated.We need to pass one associative function as a parameter,   which will be applied to the source RDD and will create anew RDD as with resulting values(i.e.  key value pair). This operation is a wide operation as data shuffling may happen across the   partitions.【本质上来讲，reduceByKey函数（说算子也可以）只作用于包含key-value的RDDS上，它是  transformation类型的算子，这也就意味着它是懒加载的（就是说不调用Action的方法，是不会去计算的  ）,在使用时，我们需要传递一个相关的函数（<em>+</em>）作为参数，这个函数将会被应用到源RDD上并且创建一个新的  RDD作为返回结果，这个算子作为data Shuffling 在分区的时候被广泛使用】  </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"需求背景：\"><a href=\"#需求背景：\" class=\"headerlink\" title=\"需求背景：\"></a>需求背景：</h1><blockquote>\n<p>统计相邻两个单词出现的次数。</p>\n</blockquote>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">val</span> s=<span class=\"string\">\"A;B;C;D;B;D;C;B;D;A;E;D;C;A;B\"</span></div><div class=\"line\"></div><div class=\"line\">s: <span class=\"type\">String</span> = <span class=\"type\">A</span>;<span class=\"type\">B</span>;<span class=\"type\">C</span>;<span class=\"type\">D</span>;<span class=\"type\">B</span>;<span class=\"type\">D</span>;<span class=\"type\">C</span>;<span class=\"type\">B</span>;<span class=\"type\">D</span>;<span class=\"type\">A</span>;<span class=\"type\">E</span>;<span class=\"type\">D</span>;<span class=\"type\">C</span>;<span class=\"type\">A</span>;<span class=\"type\">B</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">val</span> data=sc.parallelize(<span class=\"type\">Seq</span>(s))</div><div class=\"line\"></div><div class=\"line\">data.collect()</div><div class=\"line\"></div><div class=\"line\">res0: <span class=\"type\">Array</span>[<span class=\"type\">String</span>] = <span class=\"type\">Array</span>(<span class=\"type\">A</span>;<span class=\"type\">B</span>;<span class=\"type\">C</span>;<span class=\"type\">D</span>;<span class=\"type\">B</span>;<span class=\"type\">D</span>;<span class=\"type\">C</span>;<span class=\"type\">B</span>;<span class=\"type\">D</span>;<span class=\"type\">A</span>;<span class=\"type\">E</span>;<span class=\"type\">D</span>;<span class=\"type\">C</span>;<span class=\"type\">A</span>;<span class=\"type\">B</span>)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>截止目前位置是一个String类型的数组。</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">val</span> mapTemp=data.map(_.split(<span class=\"string\">\";\"</span>))</div><div class=\"line\"></div><div class=\"line\">scala&gt; mapTemp.collect</div><div class=\"line\"></div><div class=\"line\">res4: <span class=\"type\">Array</span>[<span class=\"type\">Array</span>[<span class=\"type\">String</span>]] = <span class=\"type\">Array</span>(<span class=\"type\">Array</span>(<span class=\"type\">A</span>, <span class=\"type\">B</span>, <span class=\"type\">C</span>, <span class=\"type\">D</span>, <span class=\"type\">B</span>, <span class=\"type\">D</span>, <span class=\"type\">C</span>, <span class=\"type\">B</span>, <span class=\"type\">D</span>, <span class=\"type\">A</span>, <span class=\"type\">E</span>, <span class=\"type\">D</span>, <span class=\"type\">C</span>, <span class=\"type\">A</span>, <span class=\"type\">B</span>))</div></pre></td></tr></table></figure>\n<blockquote>\n<p>map操作在于处理之前和处理之后的数据类型是一致的。</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">val</span> mapRs=data.map(_.split(<span class=\"string\">\";\"</span>)).map(x=&gt;&#123;<span class=\"keyword\">for</span>(i&lt;<span class=\"number\">-0</span> until x.length<span class=\"number\">-1</span>) <span class=\"keyword\">yield</span> (x(i)+<span class=\"string\">\",\"</span>+x(i+<span class=\"number\">1</span>),<span class=\"number\">1</span>)&#125;)</div><div class=\"line\"></div><div class=\"line\">mapRs.collect</div><div class=\"line\"></div><div class=\"line\">res1: <span class=\"type\">Array</span>[scala.collection.immutable.<span class=\"type\">IndexedSeq</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)]] = <span class=\"type\">Array</span>(<span class=\"type\">Vector</span>((<span class=\"type\">A</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">A</span>,<span class=\"number\">1</span>), (<span class=\"type\">A</span>,<span class=\"type\">E</span>,<span class=\"number\">1</span>), (<span class=\"type\">E</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">A</span>,<span class=\"number\">1</span>), (<span class=\"type\">A</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>)))</div></pre></td></tr></table></figure>\n<blockquote>\n<p><em>map输出的数据类型:Array[scala.collection.immutable.IndexedSeq[(String, Int)]]</em><br>而flatMap会把一类集合类的数据抹平从而展示的效果是元素的方式，真实效果:从Vector中遍历然后罗列出来。</p>\n</blockquote>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">val</span> flatMapRs=data.map(_.split(<span class=\"string\">\";\"</span>)).flatMap(x=&gt;&#123;<span class=\"keyword\">for</span>(i&lt;<span class=\"number\">-0</span> until x.length<span class=\"number\">-1</span>) <span class=\"keyword\">yield</span>　(x(i)+<span class=\"string\">\",\"</span>+x(i+<span class=\"number\">1</span>),<span class=\"number\">1</span>)&#125;)</div><div class=\"line\"></div><div class=\"line\">flatMapRs.collect</div><div class=\"line\"></div><div class=\"line\">res3: <span class=\"type\">Array</span>[(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)] = <span class=\"type\">Array</span>((<span class=\"type\">A</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>), (<span class=\"type\">B</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">A</span>,<span class=\"number\">1</span>), (<span class=\"type\">A</span>,<span class=\"type\">E</span>,<span class=\"number\">1</span>), (<span class=\"type\">E</span>,<span class=\"type\">D</span>,<span class=\"number\">1</span>), (<span class=\"type\">D</span>,<span class=\"type\">C</span>,<span class=\"number\">1</span>), (<span class=\"type\">C</span>,<span class=\"type\">A</span>,<span class=\"number\">1</span>), (<span class=\"type\">A</span>,<span class=\"type\">B</span>,<span class=\"number\">1</span>))</div></pre></td></tr></table></figure>\n<blockquote>\n<p>flatmap输出的数据类型:Array[(String, Int)]*</p>\n</blockquote>\n<h2 id=\"最终结果\"><a href=\"#最终结果\" class=\"headerlink\" title=\"最终结果\"></a>最终结果</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">val</span> flatMap= data.map(_.split(<span class=\"string\">\";\"</span>)).flatMap(x=&gt;&#123;<span class=\"keyword\">for</span>(i&lt;<span class=\"number\">-0</span> until x.length<span class=\"number\">-1</span>) <span class=\"keyword\">yield</span> (x(i)+<span class=\"string\">\",\"</span>+x(i+<span class=\"number\">1</span>),<span class=\"number\">1</span>)&#125;).reduceByKey(_+_).foreach(println)</div></pre></td></tr></table></figure>\n<p>(A,E,1)</p>\n<p>(C,D,1)</p>\n<p>(B,D,2)</p>\n<p>(D,B,1)</p>\n<p>(C,A,1)</p>\n<p>(C,B,1)</p>\n<p>(E,D,1)</p>\n<p>(D,A,1)</p>\n<p>(B,C,1)</p>\n<p>(D,C,2)</p>\n<p>(A,B,2)</p>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下:\"></a>总结一下:</h2><blockquote>\n<p>处理以前一定要意识到你自己最终拿到的数据的格式,如果是集合类的你则最终需要需要flat(抹平操作),从而才能使用一些函数对每个元素进行处理.</p>\n</blockquote>\n<h2 id=\"reduceByKey算数因子解释：\"><a href=\"#reduceByKey算数因子解释：\" class=\"headerlink\" title=\"reduceByKey算数因子解释：\"></a>reduceByKey算数因子解释：</h2><blockquote>\n<p>Basically reduceByKey function works only for RDDs which contains key and value pairs kind of   elements(i.e RDDs having tuple or Map as a data element). It is a transformation operation   which means it is lazily evaluated.We need to pass one associative function as a parameter,   which will be applied to the source RDD and will create anew RDD as with resulting values(i.e.  key value pair). This operation is a wide operation as data shuffling may happen across the   partitions.【本质上来讲，reduceByKey函数（说算子也可以）只作用于包含key-value的RDDS上，它是  transformation类型的算子，这也就意味着它是懒加载的（就是说不调用Action的方法，是不会去计算的  ）,在使用时，我们需要传递一个相关的函数（<em>+</em>）作为参数，这个函数将会被应用到源RDD上并且创建一个新的  RDD作为返回结果，这个算子作为data Shuffling 在分区的时候被广泛使用】  </p>\n</blockquote>\n"},{"title":"ssh 免登陆设置","date":"2017-09-29T03:28:05.000Z","_content":"\n## 需求背景:\n> 在搭建大数据平台的时候，我们测试或者入门可以在local模式下进行，但是要模拟集群环境的话，就需要设置主从模式，这里已spark为例，搭建spark的standalone模式，因为涉及到远端启动所以我们需要设置ssh免登陆，步骤如下．\n\n 1.在各个节点上使用ssh-keygen -t rsa,过程中三次回车即可,然后在当前用户的.ssh目录下面会生成私钥文件.\n 2.我们需要将这个公钥文件使用scp拷贝到其他节点并且重命名为authorized_keys．\n 3.跟有交互需求的拷贝自己的公钥文件给对方从而实现该节点可以免登陆到其他节点．．\n \n 拷贝公钥代码如下:\n``` shell\n　scp id_rsa.pub B:~/.ssh/authorized_keys\n```\n\n ","source":"_posts/ssh-免登陆设置.md","raw":"---\ntitle: ssh 免登陆设置\ndate: 2017-09-29 11:28:05\ntags: ssh hadoop spark\n---\n\n## 需求背景:\n> 在搭建大数据平台的时候，我们测试或者入门可以在local模式下进行，但是要模拟集群环境的话，就需要设置主从模式，这里已spark为例，搭建spark的standalone模式，因为涉及到远端启动所以我们需要设置ssh免登陆，步骤如下．\n\n 1.在各个节点上使用ssh-keygen -t rsa,过程中三次回车即可,然后在当前用户的.ssh目录下面会生成私钥文件.\n 2.我们需要将这个公钥文件使用scp拷贝到其他节点并且重命名为authorized_keys．\n 3.跟有交互需求的拷贝自己的公钥文件给对方从而实现该节点可以免登陆到其他节点．．\n \n 拷贝公钥代码如下:\n``` shell\n　scp id_rsa.pub B:~/.ssh/authorized_keys\n```\n\n ","slug":"ssh-免登陆设置","published":1,"updated":"2017-09-29T06:47:59.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xinw000py8ztqj3ncl1k","content":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>在搭建大数据平台的时候，我们测试或者入门可以在local模式下进行，但是要模拟集群环境的话，就需要设置主从模式，这里已spark为例，搭建spark的standalone模式，因为涉及到远端启动所以我们需要设置ssh免登陆，步骤如下．</p>\n</blockquote>\n<p> 1.在各个节点上使用ssh-keygen -t rsa,过程中三次回车即可,然后在当前用户的.ssh目录下面会生成私钥文件.<br> 2.我们需要将这个公钥文件使用scp拷贝到其他节点并且重命名为authorized_keys．<br> 3.跟有交互需求的拷贝自己的公钥文件给对方从而实现该节点可以免登陆到其他节点．．</p>\n<p> 拷贝公钥代码如下:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　scp id_rsa.pub B:~/.ssh/authorized_keys</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>在搭建大数据平台的时候，我们测试或者入门可以在local模式下进行，但是要模拟集群环境的话，就需要设置主从模式，这里已spark为例，搭建spark的standalone模式，因为涉及到远端启动所以我们需要设置ssh免登陆，步骤如下．</p>\n</blockquote>\n<p> 1.在各个节点上使用ssh-keygen -t rsa,过程中三次回车即可,然后在当前用户的.ssh目录下面会生成私钥文件.<br> 2.我们需要将这个公钥文件使用scp拷贝到其他节点并且重命名为authorized_keys．<br> 3.跟有交互需求的拷贝自己的公钥文件给对方从而实现该节点可以免登陆到其他节点．．</p>\n<p> 拷贝公钥代码如下:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　scp id_rsa.pub B:~/.ssh/authorized_keys</div></pre></td></tr></table></figure></p>\n"},{"title":"ubantu16.04怎么彻底移除mysql","date":"2017-09-18T12:58:12.000Z","_content":"\n\n# 需求背景:\n安装mysql之后不小心造成不可挽回的错误,造成崩溃,修复就没有重新安装来的省心,当然前提是在你本地损坏了.\n\n\n## 技术实现\n\n``` bash\nsudo apt purge mysql-*\nsudo rm -rf /etc/mysql/ /var/lib/mysql\nsudo apt autoremove\n```\n","source":"_posts/ubantu16-04怎么彻底移除mysql.md","raw":"---\ntitle: ubantu16.04怎么彻底移除mysql\ndate: 2017-09-18 20:58:12\ntags: uabntu mysql 移除 remove\n---\n\n\n# 需求背景:\n安装mysql之后不小心造成不可挽回的错误,造成崩溃,修复就没有重新安装来的省心,当然前提是在你本地损坏了.\n\n\n## 技术实现\n\n``` bash\nsudo apt purge mysql-*\nsudo rm -rf /etc/mysql/ /var/lib/mysql\nsudo apt autoremove\n```\n","slug":"ubantu16-04怎么彻底移除mysql","published":1,"updated":"2017-09-18T13:02:38.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xinx000qy8ztsoyhv3os","content":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h1><p>安装mysql之后不小心造成不可挽回的错误,造成崩溃,修复就没有重新安装来的省心,当然前提是在你本地损坏了.</p>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt purge mysql-*</div><div class=\"line\">sudo rm -rf /etc/mysql/ /var/lib/mysql</div><div class=\"line\">sudo apt autoremove</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h1><p>安装mysql之后不小心造成不可挽回的错误,造成崩溃,修复就没有重新安装来的省心,当然前提是在你本地损坏了.</p>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现\"></a>技术实现</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt purge mysql-*</div><div class=\"line\">sudo rm -rf /etc/mysql/ /var/lib/mysql</div><div class=\"line\">sudo apt autoremove</div></pre></td></tr></table></figure>\n"},{"title":"sublime 给文本排序","date":"2017-09-21T08:38:26.000Z","_content":"\n## 需求背景:\n\n>工作中有很多需求，例如：你需要把数据排序从而便于处理、一些约定好的算法需要你将所有的key按照顺序排好然后加密处理，这时，你就可以利用工具，那么sublime 怎么通过快捷键给文本按照首字母字典顺序排序?\n\n## 解决方案:\n### ①方案一\n>前提数据多行排成列，然后\n\n``` lsl\n1.ctrl+A\n2.F9\n```\n### ②方案二\n>放到文本文件中，然后使用如下命令去排序(有操作系统限制)\n\n``` bash\nsort file\n```\n\n## 结言:\n>很容易上手。\n\n\n","source":"_posts/sublime-给文本排序.md","raw":"---\ntitle: sublime 给文本排序\ndate: 2017-09-21 16:38:26\ntags:\n---\n\n## 需求背景:\n\n>工作中有很多需求，例如：你需要把数据排序从而便于处理、一些约定好的算法需要你将所有的key按照顺序排好然后加密处理，这时，你就可以利用工具，那么sublime 怎么通过快捷键给文本按照首字母字典顺序排序?\n\n## 解决方案:\n### ①方案一\n>前提数据多行排成列，然后\n\n``` lsl\n1.ctrl+A\n2.F9\n```\n### ②方案二\n>放到文本文件中，然后使用如下命令去排序(有操作系统限制)\n\n``` bash\nsort file\n```\n\n## 结言:\n>很容易上手。\n\n\n","slug":"sublime-给文本排序","published":1,"updated":"2017-09-21T08:54:24.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xiny000sy8zteyptvixq","content":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>工作中有很多需求，例如：你需要把数据排序从而便于处理、一些约定好的算法需要你将所有的key按照顺序排好然后加密处理，这时，你就可以利用工具，那么sublime 怎么通过快捷键给文本按照首字母字典顺序排序?</p>\n</blockquote>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><h3 id=\"①方案一\"><a href=\"#①方案一\" class=\"headerlink\" title=\"①方案一\"></a>①方案一</h3><blockquote>\n<p>前提数据多行排成列，然后</p>\n</blockquote>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.</span>ctrl+A</div><div class=\"line\"><span class=\"number\">2.</span>F9</div></pre></td></tr></table></figure>\n<h3 id=\"②方案二\"><a href=\"#②方案二\" class=\"headerlink\" title=\"②方案二\"></a>②方案二</h3><blockquote>\n<p>放到文本文件中，然后使用如下命令去排序(有操作系统限制)</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sort file</div></pre></td></tr></table></figure>\n<h2 id=\"结言\"><a href=\"#结言\" class=\"headerlink\" title=\"结言:\"></a>结言:</h2><blockquote>\n<p>很容易上手。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>工作中有很多需求，例如：你需要把数据排序从而便于处理、一些约定好的算法需要你将所有的key按照顺序排好然后加密处理，这时，你就可以利用工具，那么sublime 怎么通过快捷键给文本按照首字母字典顺序排序?</p>\n</blockquote>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><h3 id=\"①方案一\"><a href=\"#①方案一\" class=\"headerlink\" title=\"①方案一\"></a>①方案一</h3><blockquote>\n<p>前提数据多行排成列，然后</p>\n</blockquote>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.</span>ctrl+A</div><div class=\"line\"><span class=\"number\">2.</span>F9</div></pre></td></tr></table></figure>\n<h3 id=\"②方案二\"><a href=\"#②方案二\" class=\"headerlink\" title=\"②方案二\"></a>②方案二</h3><blockquote>\n<p>放到文本文件中，然后使用如下命令去排序(有操作系统限制)</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sort file</div></pre></td></tr></table></figure>\n<h2 id=\"结言\"><a href=\"#结言\" class=\"headerlink\" title=\"结言:\"></a>结言:</h2><blockquote>\n<p>很容易上手。</p>\n</blockquote>\n"},{"title":"如何在ubantu中设置任务栏和菜单中的快速启动和搜索","date":"2017-09-19T06:19:49.000Z","_content":"## 背景需求:\n>一些应用程序（例如很多.sh程序）如果想在Ubuntu中添加到Dash home中进行快速的启动.\n\n## 场景分析:\n>需要找到/usr/share/applications这个目录，其中存放的全部是dash中的启动器，将你需要的程序xxx添加其中即可。\n\n## 技术实现:\n>具体操作步骤为：\n\n``` bash\ncd /usr/share/applications sudo gedit xxx.desktop\n```\n\n>打开需要编辑的文本内容为：\n\n``` ini\n[Desktop Entry] \nVersion=1.0 \nName=robomongo\nGenericName=robomongo\nKeywords=mongo;robo;robomongo (此配置是在程序搜索时，可以使用罗列的关键字)\nExec=/home/username/xxx.sh（这个是启动程序需要执行的文件路径名） \nTerminal=false \nIcon=/home/username/xxx.png（这个是图标，这个一般程序里面不带，可以去官网找logo） \nType=Application \nCategories=Development\n```\n\n>这样就可以在dash中看到xxx的启动器图标了，也可以直接将其添加锁定到launcher","source":"_posts/如何在ubantu中设置任务栏和菜单中的快速启动和搜索.md","raw":"---\ntitle: 如何在ubantu中设置任务栏和菜单中的快速启动和搜索\ndate: 2017-09-19 14:19:49\ntags: ubantu shell dash\n---\n## 背景需求:\n>一些应用程序（例如很多.sh程序）如果想在Ubuntu中添加到Dash home中进行快速的启动.\n\n## 场景分析:\n>需要找到/usr/share/applications这个目录，其中存放的全部是dash中的启动器，将你需要的程序xxx添加其中即可。\n\n## 技术实现:\n>具体操作步骤为：\n\n``` bash\ncd /usr/share/applications sudo gedit xxx.desktop\n```\n\n>打开需要编辑的文本内容为：\n\n``` ini\n[Desktop Entry] \nVersion=1.0 \nName=robomongo\nGenericName=robomongo\nKeywords=mongo;robo;robomongo (此配置是在程序搜索时，可以使用罗列的关键字)\nExec=/home/username/xxx.sh（这个是启动程序需要执行的文件路径名） \nTerminal=false \nIcon=/home/username/xxx.png（这个是图标，这个一般程序里面不带，可以去官网找logo） \nType=Application \nCategories=Development\n```\n\n>这样就可以在dash中看到xxx的启动器图标了，也可以直接将其添加锁定到launcher","slug":"如何在ubantu中设置任务栏和菜单中的快速启动和搜索","published":1,"updated":"2017-09-21T08:14:46.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8p9xinz000uy8ztoymmlqm5","content":"<h2 id=\"背景需求\"><a href=\"#背景需求\" class=\"headerlink\" title=\"背景需求:\"></a>背景需求:</h2><blockquote>\n<p>一些应用程序（例如很多.sh程序）如果想在Ubuntu中添加到Dash home中进行快速的启动.</p>\n</blockquote>\n<h2 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析:\"></a>场景分析:</h2><blockquote>\n<p>需要找到/usr/share/applications这个目录，其中存放的全部是dash中的启动器，将你需要的程序xxx添加其中即可。</p>\n</blockquote>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现:\"></a>技术实现:</h2><blockquote>\n<p>具体操作步骤为：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> /usr/share/applications sudo gedit xxx.desktop</div></pre></td></tr></table></figure>\n<blockquote>\n<p>打开需要编辑的文本内容为：</p>\n</blockquote>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\">[Desktop Entry]</span> </div><div class=\"line\"><span class=\"attr\">Version</span>=<span class=\"number\">1.0</span> </div><div class=\"line\"><span class=\"attr\">Name</span>=robomongo</div><div class=\"line\"><span class=\"attr\">GenericName</span>=robomongo</div><div class=\"line\"><span class=\"attr\">Keywords</span>=mongo;robo;robomongo (此配置是在程序搜索时，可以使用罗列的关键字)</div><div class=\"line\"><span class=\"attr\">Exec</span>=/home/username/xxx.sh（这个是启动程序需要执行的文件路径名） </div><div class=\"line\"><span class=\"attr\">Terminal</span>=<span class=\"literal\">false</span> </div><div class=\"line\"><span class=\"attr\">Icon</span>=/home/username/xxx.png（这个是图标，这个一般程序里面不带，可以去官网找logo） </div><div class=\"line\"><span class=\"attr\">Type</span>=Application </div><div class=\"line\"><span class=\"attr\">Categories</span>=Development</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这样就可以在dash中看到xxx的启动器图标了，也可以直接将其添加锁定到launcher</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景需求\"><a href=\"#背景需求\" class=\"headerlink\" title=\"背景需求:\"></a>背景需求:</h2><blockquote>\n<p>一些应用程序（例如很多.sh程序）如果想在Ubuntu中添加到Dash home中进行快速的启动.</p>\n</blockquote>\n<h2 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析:\"></a>场景分析:</h2><blockquote>\n<p>需要找到/usr/share/applications这个目录，其中存放的全部是dash中的启动器，将你需要的程序xxx添加其中即可。</p>\n</blockquote>\n<h2 id=\"技术实现\"><a href=\"#技术实现\" class=\"headerlink\" title=\"技术实现:\"></a>技术实现:</h2><blockquote>\n<p>具体操作步骤为：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> /usr/share/applications sudo gedit xxx.desktop</div></pre></td></tr></table></figure>\n<blockquote>\n<p>打开需要编辑的文本内容为：</p>\n</blockquote>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\">[Desktop Entry]</span> </div><div class=\"line\"><span class=\"attr\">Version</span>=<span class=\"number\">1.0</span> </div><div class=\"line\"><span class=\"attr\">Name</span>=robomongo</div><div class=\"line\"><span class=\"attr\">GenericName</span>=robomongo</div><div class=\"line\"><span class=\"attr\">Keywords</span>=mongo;robo;robomongo (此配置是在程序搜索时，可以使用罗列的关键字)</div><div class=\"line\"><span class=\"attr\">Exec</span>=/home/username/xxx.sh（这个是启动程序需要执行的文件路径名） </div><div class=\"line\"><span class=\"attr\">Terminal</span>=<span class=\"literal\">false</span> </div><div class=\"line\"><span class=\"attr\">Icon</span>=/home/username/xxx.png（这个是图标，这个一般程序里面不带，可以去官网找logo） </div><div class=\"line\"><span class=\"attr\">Type</span>=Application </div><div class=\"line\"><span class=\"attr\">Categories</span>=Development</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这样就可以在dash中看到xxx的启动器图标了，也可以直接将其添加锁定到launcher</p>\n</blockquote>\n"},{"title":"shell 获取上个月或者上一年","date":"2017-09-21T08:26:33.000Z","toc":true,"comments":1,"_content":"## 需求背景:\n>开发过程中会遇到很多情况，有用到date函数去获得上个月（上一年）的需求，比如用来获取上个月的日志或者上个月的数据之类的诉求。\n\n## 解决方案:\n\n``` bash\nlastMonth=`date -d \"1 month ago\" +%Y_%m`\nlastYear=`date -d \"1 year ago\" +%Y_%m`\n```\n\n## 结言：\n>感觉很直观，很容易记住。\n","source":"_posts/shell-获取上个月或者上一年.md","raw":"---\ntitle: shell 获取上个月或者上一年\ndate: 2017-09-21 16:26:33\ntags: shell  date\ntoc: true\ncomments: true\n---\n## 需求背景:\n>开发过程中会遇到很多情况，有用到date函数去获得上个月（上一年）的需求，比如用来获取上个月的日志或者上个月的数据之类的诉求。\n\n## 解决方案:\n\n``` bash\nlastMonth=`date -d \"1 month ago\" +%Y_%m`\nlastYear=`date -d \"1 year ago\" +%Y_%m`\n```\n\n## 结言：\n>感觉很直观，很容易记住。\n","slug":"shell-获取上个月或者上一年","published":1,"updated":"2017-09-21T08:32:25.794Z","layout":"post","photos":[],"link":"","_id":"cj8p9xio0000wy8zt50jw180m","content":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>开发过程中会遇到很多情况，有用到date函数去获得上个月（上一年）的需求，比如用来获取上个月的日志或者上个月的数据之类的诉求。</p>\n</blockquote>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">lastMonth=`date -d <span class=\"string\">\"1 month ago\"</span> +%Y_%m`</div><div class=\"line\">lastYear=`date -d <span class=\"string\">\"1 year ago\"</span> +%Y_%m`</div></pre></td></tr></table></figure>\n<h2 id=\"结言：\"><a href=\"#结言：\" class=\"headerlink\" title=\"结言：\"></a>结言：</h2><blockquote>\n<p>感觉很直观，很容易记住。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景:\"></a>需求背景:</h2><blockquote>\n<p>开发过程中会遇到很多情况，有用到date函数去获得上个月（上一年）的需求，比如用来获取上个月的日志或者上个月的数据之类的诉求。</p>\n</blockquote>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">lastMonth=`date -d <span class=\"string\">\"1 month ago\"</span> +%Y_%m`</div><div class=\"line\">lastYear=`date -d <span class=\"string\">\"1 year ago\"</span> +%Y_%m`</div></pre></td></tr></table></figure>\n<h2 id=\"结言：\"><a href=\"#结言：\" class=\"headerlink\" title=\"结言：\"></a>结言：</h2><blockquote>\n<p>感觉很直观，很容易记住。</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj8p9xin60000y8zt85pibhfd","tag_id":"cj8p9xine0002y8zteeylvjtz","_id":"cj8p9xink0007y8ztwrztsqef"},{"post_id":"cj8p9xinb0001y8zt5jwjmifm","tag_id":"cj8p9xink0006y8zt77onb53b","_id":"cj8p9xino000cy8ztle5kqjd1"},{"post_id":"cj8p9xini0004y8ztx3r1ls6g","tag_id":"cj8p9xinn000ay8zti5q3mhcp","_id":"cj8p9xinr000gy8ztijn52dc9"},{"post_id":"cj8p9xinj0005y8ztt7szv5ew","tag_id":"cj8p9xinp000ey8zt7zytf8kp","_id":"cj8p9xint000ky8zt1x6zosoz"},{"post_id":"cj8p9xinl0008y8ztv26wcbuc","tag_id":"cj8p9xins000iy8ztyg1vybdw","_id":"cj8p9xinv000oy8zttnutntmn"},{"post_id":"cj8p9xinm0009y8ztw92kd5af","tag_id":"cj8p9xinv000ny8ztmnn8uz68","_id":"cj8p9xiny000ty8ztjg3h9b53"},{"post_id":"cj8p9xinn000by8zt731v9ru9","tag_id":"cj8p9xinx000ry8ztqros8yaj","_id":"cj8p9xio1000xy8zt28kd9ghd"},{"post_id":"cj8p9xinp000dy8zt2a61msc1","tag_id":"cj8p9xio0000vy8ztgsuor34t","_id":"cj8p9xio2000zy8ztwb4opvbs"},{"post_id":"cj8p9xinq000fy8ztmiminhs7","tag_id":"cj8p9xio1000yy8zt5c48tui1","_id":"cj8p9xio20011y8ztz4c4i3n8"},{"post_id":"cj8p9xinr000hy8ztfy230im2","tag_id":"cj8p9xio20010y8ztuc8okovw","_id":"cj8p9xio30013y8zti2wycwc3"},{"post_id":"cj8p9xins000jy8ztnzd4s3dq","tag_id":"cj8p9xio30012y8zttpcib27a","_id":"cj8p9xio30015y8zteiy4mwp4"},{"post_id":"cj8p9xint000ly8zt4gacwg50","tag_id":"cj8p9xio30014y8zt1uqmjofm","_id":"cj8p9xio40017y8zt4cpxq0xy"},{"post_id":"cj8p9xinu000my8zt5wfhdvkh","tag_id":"cj8p9xio40016y8ztwtebrc23","_id":"cj8p9xio40019y8ztfe8ejluz"},{"post_id":"cj8p9xinw000py8ztqj3ncl1k","tag_id":"cj8p9xio40018y8zt4pllb15e","_id":"cj8p9xio5001by8ztnnl8k8ox"},{"post_id":"cj8p9xinx000qy8ztsoyhv3os","tag_id":"cj8p9xio4001ay8ztibd6ody1","_id":"cj8p9xio5001dy8zth7kmc7yn"},{"post_id":"cj8p9xinz000uy8ztoymmlqm5","tag_id":"cj8p9xio5001cy8ztg0drp58t","_id":"cj8p9xio6001fy8ztybw51030"},{"post_id":"cj8p9xio0000wy8zt50jw180m","tag_id":"cj8p9xio6001ey8ztxna11r67","_id":"cj8p9xio6001gy8ztcu2plyaa"}],"Tag":[{"name":"apache https ssl NoClassDefFound","_id":"cj8p9xine0002y8zteeylvjtz"},{"name":"shell awk","_id":"cj8p9xink0006y8zt77onb53b"},{"name":"git commit","_id":"cj8p9xinn000ay8zti5q3mhcp"},{"name":"hexo yilla github","_id":"cj8p9xinp000ey8zt7zytf8kp"},{"name":"mapreduce shuffer","_id":"cj8p9xins000iy8ztyg1vybdw"},{"name":"python mongo count","_id":"cj8p9xinv000ny8ztmnn8uz68"},{"name":"mongo groupby where","_id":"cj8p9xinx000ry8ztqros8yaj"},{"name":"python date count sum aggr mean panda","_id":"cj8p9xio0000vy8ztgsuor34t"},{"name":"python mongo","_id":"cj8p9xio1000yy8zt5c48tui1"},{"name":"shell sed","_id":"cj8p9xio20010y8ztuc8okovw"},{"name":"spark lzo","_id":"cj8p9xio30012y8zttpcib27a"},{"name":"spark not match","_id":"cj8p9xio30014y8zt1uqmjofm"},{"name":"spark scala map flatmap","_id":"cj8p9xio40016y8ztwtebrc23"},{"name":"ssh hadoop spark","_id":"cj8p9xio40018y8zt4pllb15e"},{"name":"uabntu mysql 移除 remove","_id":"cj8p9xio4001ay8ztibd6ody1"},{"name":"ubantu shell dash","_id":"cj8p9xio5001cy8ztg0drp58t"},{"name":"shell  date","_id":"cj8p9xio6001ey8ztxna11r67"}]}}